{
  "version": 3,
  "sources": ["../../three/examples/jsm/utils/BufferGeometryUtils.js", "../../src/IFC/components/IFCModel.ts", "../../src/IFC/components/IFCParser.ts", "../../src/IFC/components/subsets/ItemsMap.ts", "../../src/IFC/components/subsets/SubsetUtils.ts", "../../src/IFC/components/subsets/SubsetCreator.ts", "../../src/IFC/components/subsets/SubsetManager.ts", "../../src/IFC/BaseDefinitions.ts", "../../src/IFC/components/properties/BasePropertyManager.ts", "../../src/IFC/components/IFCElementsMap.ts", "../../src/IFC/components/properties/WebIfcPropertyManager.ts", "../../src/IFC/components/IfcTypesMap.ts", "../../src/IFC/components/properties/JSONPropertyManager.ts", "../../src/IFC/components/properties/GeometryTypes.ts", "../../src/IFC/components/properties/PropertySerializer.ts", "../../src/IFC/components/properties/PropertyManager.ts", "../../src/IFC/components/TypeManager.ts", "../../src/IFC/components/BvhManager.ts", "../../src/IFC/web-workers/BaseDefinitions.ts", "../../src/IFC/web-workers/serializer/Vector.ts", "../../src/IFC/web-workers/serializer/IfcGeometry.ts", "../../src/IFC/web-workers/serializer/FlatMesh.ts", "../../src/IFC/web-workers/serializer/FlatMeshVector.ts", "../../src/IFC/web-workers/serializer/Material.ts", "../../src/IFC/web-workers/serializer/Geometry.ts", "../../src/IFC/web-workers/serializer/Mesh.ts", "../../src/IFC/web-workers/serializer/Serializer.ts", "../../src/IFC/web-workers/handlers/PropertyHandler.ts", "../../src/IFC/web-workers/handlers/WebIfcHandler.ts", "../../src/IFC/web-workers/handlers/WorkerStateHandler.ts", "../../src/IFC/indexedDB/IndexedDatabase.ts", "../../src/IFC/web-workers/handlers/ParserHandler.ts", "../../src/IFC/web-workers/IFCWorkerHandler.ts", "../../src/IFC/components/MemoryCleaner.ts", "../../src/IFC/components/IFCUtils.ts", "../../src/IFC/components/sequence/Data.ts", "../../src/IFC/components/IFCManager.ts", "../../src/IFCLoader.ts"],
  "sourcesContent": ["import {\n\tBufferAttribute,\n\tBufferGeometry,\n\tFloat32BufferAttribute,\n\tInstancedBufferAttribute,\n\tInterleavedBuffer,\n\tInterleavedBufferAttribute,\n\tTriangleFanDrawMode,\n\tTriangleStripDrawMode,\n\tTrianglesDrawMode,\n\tVector3,\n} from 'three';\n\nfunction computeMikkTSpaceTangents( geometry, MikkTSpace, negateSign = true ) {\n\n\tif ( ! MikkTSpace || ! MikkTSpace.isReady ) {\n\n\t\tthrow new Error( 'BufferGeometryUtils: Initialized MikkTSpace library required.' );\n\n\t}\n\n\tif ( ! geometry.hasAttribute( 'position' ) || ! geometry.hasAttribute( 'normal' ) || ! geometry.hasAttribute( 'uv' ) ) {\n\n\t\tthrow new Error( 'BufferGeometryUtils: Tangents require \"position\", \"normal\", and \"uv\" attributes.' );\n\n\t}\n\n\tfunction getAttributeArray( attribute ) {\n\n\t\tif ( attribute.normalized || attribute.isInterleavedBufferAttribute ) {\n\n\t\t\tconst dstArray = new Float32Array( attribute.count * attribute.itemSize );\n\n\t\t\tfor ( let i = 0, j = 0; i < attribute.count; i ++ ) {\n\n\t\t\t\tdstArray[ j ++ ] = attribute.getX( i );\n\t\t\t\tdstArray[ j ++ ] = attribute.getY( i );\n\n\t\t\t\tif ( attribute.itemSize > 2 ) {\n\n\t\t\t\t\tdstArray[ j ++ ] = attribute.getZ( i );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn dstArray;\n\n\t\t}\n\n\t\tif ( attribute.array instanceof Float32Array ) {\n\n\t\t\treturn attribute.array;\n\n\t\t}\n\n\t\treturn new Float32Array( attribute.array );\n\n\t}\n\n\t// MikkTSpace algorithm requires non-indexed input.\n\n\tconst _geometry = geometry.index ? geometry.toNonIndexed() : geometry;\n\n\t// Compute vertex tangents.\n\n\tconst tangents = MikkTSpace.generateTangents(\n\n\t\tgetAttributeArray( _geometry.attributes.position ),\n\t\tgetAttributeArray( _geometry.attributes.normal ),\n\t\tgetAttributeArray( _geometry.attributes.uv )\n\n\t);\n\n\t// Texture coordinate convention of glTF differs from the apparent\n\t// default of the MikkTSpace library; .w component must be flipped.\n\n\tif ( negateSign ) {\n\n\t\tfor ( let i = 3; i < tangents.length; i += 4 ) {\n\n\t\t\ttangents[ i ] *= - 1;\n\n\t\t}\n\n\t}\n\n\t//\n\n\t_geometry.setAttribute( 'tangent', new BufferAttribute( tangents, 4 ) );\n\n\tif ( geometry !== _geometry ) {\n\n\t\tgeometry.copy( _geometry );\n\n\t}\n\n\treturn geometry;\n\n}\n\n/**\n * @param  {Array<BufferGeometry>} geometries\n * @param  {Boolean} useGroups\n * @return {BufferGeometry}\n */\nfunction mergeGeometries( geometries, useGroups = false ) {\n\n\tconst isIndexed = geometries[ 0 ].index !== null;\n\n\tconst attributesUsed = new Set( Object.keys( geometries[ 0 ].attributes ) );\n\tconst morphAttributesUsed = new Set( Object.keys( geometries[ 0 ].morphAttributes ) );\n\n\tconst attributes = {};\n\tconst morphAttributes = {};\n\n\tconst morphTargetsRelative = geometries[ 0 ].morphTargetsRelative;\n\n\tconst mergedGeometry = new BufferGeometry();\n\n\tlet offset = 0;\n\n\tfor ( let i = 0; i < geometries.length; ++ i ) {\n\n\t\tconst geometry = geometries[ i ];\n\t\tlet attributesCount = 0;\n\n\t\t// ensure that all geometries are indexed, or none\n\n\t\tif ( isIndexed !== ( geometry.index !== null ) ) {\n\n\t\t\tconsole.error( 'THREE.BufferGeometryUtils: .mergeGeometries() failed with geometry at index ' + i + '. All geometries must have compatible attributes; make sure index attribute exists among all geometries, or in none of them.' );\n\t\t\treturn null;\n\n\t\t}\n\n\t\t// gather attributes, exit early if they're different\n\n\t\tfor ( const name in geometry.attributes ) {\n\n\t\t\tif ( ! attributesUsed.has( name ) ) {\n\n\t\t\t\tconsole.error( 'THREE.BufferGeometryUtils: .mergeGeometries() failed with geometry at index ' + i + '. All geometries must have compatible attributes; make sure \"' + name + '\" attribute exists among all geometries, or in none of them.' );\n\t\t\t\treturn null;\n\n\t\t\t}\n\n\t\t\tif ( attributes[ name ] === undefined ) attributes[ name ] = [];\n\n\t\t\tattributes[ name ].push( geometry.attributes[ name ] );\n\n\t\t\tattributesCount ++;\n\n\t\t}\n\n\t\t// ensure geometries have the same number of attributes\n\n\t\tif ( attributesCount !== attributesUsed.size ) {\n\n\t\t\tconsole.error( 'THREE.BufferGeometryUtils: .mergeGeometries() failed with geometry at index ' + i + '. Make sure all geometries have the same number of attributes.' );\n\t\t\treturn null;\n\n\t\t}\n\n\t\t// gather morph attributes, exit early if they're different\n\n\t\tif ( morphTargetsRelative !== geometry.morphTargetsRelative ) {\n\n\t\t\tconsole.error( 'THREE.BufferGeometryUtils: .mergeGeometries() failed with geometry at index ' + i + '. .morphTargetsRelative must be consistent throughout all geometries.' );\n\t\t\treturn null;\n\n\t\t}\n\n\t\tfor ( const name in geometry.morphAttributes ) {\n\n\t\t\tif ( ! morphAttributesUsed.has( name ) ) {\n\n\t\t\t\tconsole.error( 'THREE.BufferGeometryUtils: .mergeGeometries() failed with geometry at index ' + i + '.  .morphAttributes must be consistent throughout all geometries.' );\n\t\t\t\treturn null;\n\n\t\t\t}\n\n\t\t\tif ( morphAttributes[ name ] === undefined ) morphAttributes[ name ] = [];\n\n\t\t\tmorphAttributes[ name ].push( geometry.morphAttributes[ name ] );\n\n\t\t}\n\n\t\tif ( useGroups ) {\n\n\t\t\tlet count;\n\n\t\t\tif ( isIndexed ) {\n\n\t\t\t\tcount = geometry.index.count;\n\n\t\t\t} else if ( geometry.attributes.position !== undefined ) {\n\n\t\t\t\tcount = geometry.attributes.position.count;\n\n\t\t\t} else {\n\n\t\t\t\tconsole.error( 'THREE.BufferGeometryUtils: .mergeGeometries() failed with geometry at index ' + i + '. The geometry must have either an index or a position attribute' );\n\t\t\t\treturn null;\n\n\t\t\t}\n\n\t\t\tmergedGeometry.addGroup( offset, count, i );\n\n\t\t\toffset += count;\n\n\t\t}\n\n\t}\n\n\t// merge indices\n\n\tif ( isIndexed ) {\n\n\t\tlet indexOffset = 0;\n\t\tconst mergedIndex = [];\n\n\t\tfor ( let i = 0; i < geometries.length; ++ i ) {\n\n\t\t\tconst index = geometries[ i ].index;\n\n\t\t\tfor ( let j = 0; j < index.count; ++ j ) {\n\n\t\t\t\tmergedIndex.push( index.getX( j ) + indexOffset );\n\n\t\t\t}\n\n\t\t\tindexOffset += geometries[ i ].attributes.position.count;\n\n\t\t}\n\n\t\tmergedGeometry.setIndex( mergedIndex );\n\n\t}\n\n\t// merge attributes\n\n\tfor ( const name in attributes ) {\n\n\t\tconst mergedAttribute = mergeAttributes( attributes[ name ] );\n\n\t\tif ( ! mergedAttribute ) {\n\n\t\t\tconsole.error( 'THREE.BufferGeometryUtils: .mergeGeometries() failed while trying to merge the ' + name + ' attribute.' );\n\t\t\treturn null;\n\n\t\t}\n\n\t\tmergedGeometry.setAttribute( name, mergedAttribute );\n\n\t}\n\n\t// merge morph attributes\n\n\tfor ( const name in morphAttributes ) {\n\n\t\tconst numMorphTargets = morphAttributes[ name ][ 0 ].length;\n\n\t\tif ( numMorphTargets === 0 ) break;\n\n\t\tmergedGeometry.morphAttributes = mergedGeometry.morphAttributes || {};\n\t\tmergedGeometry.morphAttributes[ name ] = [];\n\n\t\tfor ( let i = 0; i < numMorphTargets; ++ i ) {\n\n\t\t\tconst morphAttributesToMerge = [];\n\n\t\t\tfor ( let j = 0; j < morphAttributes[ name ].length; ++ j ) {\n\n\t\t\t\tmorphAttributesToMerge.push( morphAttributes[ name ][ j ][ i ] );\n\n\t\t\t}\n\n\t\t\tconst mergedMorphAttribute = mergeAttributes( morphAttributesToMerge );\n\n\t\t\tif ( ! mergedMorphAttribute ) {\n\n\t\t\t\tconsole.error( 'THREE.BufferGeometryUtils: .mergeGeometries() failed while trying to merge the ' + name + ' morphAttribute.' );\n\t\t\t\treturn null;\n\n\t\t\t}\n\n\t\t\tmergedGeometry.morphAttributes[ name ].push( mergedMorphAttribute );\n\n\t\t}\n\n\t}\n\n\treturn mergedGeometry;\n\n}\n\n/**\n * @param {Array<BufferAttribute>} attributes\n * @return {BufferAttribute}\n */\nfunction mergeAttributes( attributes ) {\n\n\tlet TypedArray;\n\tlet itemSize;\n\tlet normalized;\n\tlet arrayLength = 0;\n\n\tfor ( let i = 0; i < attributes.length; ++ i ) {\n\n\t\tconst attribute = attributes[ i ];\n\n\t\tif ( attribute.isInterleavedBufferAttribute ) {\n\n\t\t\tconsole.error( 'THREE.BufferGeometryUtils: .mergeAttributes() failed. InterleavedBufferAttributes are not supported.' );\n\t\t\treturn null;\n\n\t\t}\n\n\t\tif ( TypedArray === undefined ) TypedArray = attribute.array.constructor;\n\t\tif ( TypedArray !== attribute.array.constructor ) {\n\n\t\t\tconsole.error( 'THREE.BufferGeometryUtils: .mergeAttributes() failed. BufferAttribute.array must be of consistent array types across matching attributes.' );\n\t\t\treturn null;\n\n\t\t}\n\n\t\tif ( itemSize === undefined ) itemSize = attribute.itemSize;\n\t\tif ( itemSize !== attribute.itemSize ) {\n\n\t\t\tconsole.error( 'THREE.BufferGeometryUtils: .mergeAttributes() failed. BufferAttribute.itemSize must be consistent across matching attributes.' );\n\t\t\treturn null;\n\n\t\t}\n\n\t\tif ( normalized === undefined ) normalized = attribute.normalized;\n\t\tif ( normalized !== attribute.normalized ) {\n\n\t\t\tconsole.error( 'THREE.BufferGeometryUtils: .mergeAttributes() failed. BufferAttribute.normalized must be consistent across matching attributes.' );\n\t\t\treturn null;\n\n\t\t}\n\n\t\tarrayLength += attribute.array.length;\n\n\t}\n\n\tconst array = new TypedArray( arrayLength );\n\tlet offset = 0;\n\n\tfor ( let i = 0; i < attributes.length; ++ i ) {\n\n\t\tarray.set( attributes[ i ].array, offset );\n\n\t\toffset += attributes[ i ].array.length;\n\n\t}\n\n\treturn new BufferAttribute( array, itemSize, normalized );\n\n}\n\n/**\n * @param {BufferAttribute}\n * @return {BufferAttribute}\n */\nexport function deepCloneAttribute( attribute ) {\n\n\tif ( attribute.isInstancedInterleavedBufferAttribute || attribute.isInterleavedBufferAttribute ) {\n\n\t\treturn deinterleaveAttribute( attribute );\n\n\t}\n\n\tif ( attribute.isInstancedBufferAttribute ) {\n\n\t\treturn new InstancedBufferAttribute().copy( attribute );\n\n\t}\n\n\treturn new BufferAttribute().copy( attribute );\n\n}\n\n/**\n * @param {Array<BufferAttribute>} attributes\n * @return {Array<InterleavedBufferAttribute>}\n */\nfunction interleaveAttributes( attributes ) {\n\n\t// Interleaves the provided attributes into an InterleavedBuffer and returns\n\t// a set of InterleavedBufferAttributes for each attribute\n\tlet TypedArray;\n\tlet arrayLength = 0;\n\tlet stride = 0;\n\n\t// calculate the length and type of the interleavedBuffer\n\tfor ( let i = 0, l = attributes.length; i < l; ++ i ) {\n\n\t\tconst attribute = attributes[ i ];\n\n\t\tif ( TypedArray === undefined ) TypedArray = attribute.array.constructor;\n\t\tif ( TypedArray !== attribute.array.constructor ) {\n\n\t\t\tconsole.error( 'AttributeBuffers of different types cannot be interleaved' );\n\t\t\treturn null;\n\n\t\t}\n\n\t\tarrayLength += attribute.array.length;\n\t\tstride += attribute.itemSize;\n\n\t}\n\n\t// Create the set of buffer attributes\n\tconst interleavedBuffer = new InterleavedBuffer( new TypedArray( arrayLength ), stride );\n\tlet offset = 0;\n\tconst res = [];\n\tconst getters = [ 'getX', 'getY', 'getZ', 'getW' ];\n\tconst setters = [ 'setX', 'setY', 'setZ', 'setW' ];\n\n\tfor ( let j = 0, l = attributes.length; j < l; j ++ ) {\n\n\t\tconst attribute = attributes[ j ];\n\t\tconst itemSize = attribute.itemSize;\n\t\tconst count = attribute.count;\n\t\tconst iba = new InterleavedBufferAttribute( interleavedBuffer, itemSize, offset, attribute.normalized );\n\t\tres.push( iba );\n\n\t\toffset += itemSize;\n\n\t\t// Move the data for each attribute into the new interleavedBuffer\n\t\t// at the appropriate offset\n\t\tfor ( let c = 0; c < count; c ++ ) {\n\n\t\t\tfor ( let k = 0; k < itemSize; k ++ ) {\n\n\t\t\t\tiba[ setters[ k ] ]( c, attribute[ getters[ k ] ]( c ) );\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\treturn res;\n\n}\n\n// returns a new, non-interleaved version of the provided attribute\nexport function deinterleaveAttribute( attribute ) {\n\n\tconst cons = attribute.data.array.constructor;\n\tconst count = attribute.count;\n\tconst itemSize = attribute.itemSize;\n\tconst normalized = attribute.normalized;\n\n\tconst array = new cons( count * itemSize );\n\tlet newAttribute;\n\tif ( attribute.isInstancedInterleavedBufferAttribute ) {\n\n\t\tnewAttribute = new InstancedBufferAttribute( array, itemSize, normalized, attribute.meshPerAttribute );\n\n\t} else {\n\n\t\tnewAttribute = new BufferAttribute( array, itemSize, normalized );\n\n\t}\n\n\tfor ( let i = 0; i < count; i ++ ) {\n\n\t\tnewAttribute.setX( i, attribute.getX( i ) );\n\n\t\tif ( itemSize >= 2 ) {\n\n\t\t\tnewAttribute.setY( i, attribute.getY( i ) );\n\n\t\t}\n\n\t\tif ( itemSize >= 3 ) {\n\n\t\t\tnewAttribute.setZ( i, attribute.getZ( i ) );\n\n\t\t}\n\n\t\tif ( itemSize >= 4 ) {\n\n\t\t\tnewAttribute.setW( i, attribute.getW( i ) );\n\n\t\t}\n\n\t}\n\n\treturn newAttribute;\n\n}\n\n// deinterleaves all attributes on the geometry\nexport function deinterleaveGeometry( geometry ) {\n\n\tconst attributes = geometry.attributes;\n\tconst morphTargets = geometry.morphTargets;\n\tconst attrMap = new Map();\n\n\tfor ( const key in attributes ) {\n\n\t\tconst attr = attributes[ key ];\n\t\tif ( attr.isInterleavedBufferAttribute ) {\n\n\t\t\tif ( ! attrMap.has( attr ) ) {\n\n\t\t\t\tattrMap.set( attr, deinterleaveAttribute( attr ) );\n\n\t\t\t}\n\n\t\t\tattributes[ key ] = attrMap.get( attr );\n\n\t\t}\n\n\t}\n\n\tfor ( const key in morphTargets ) {\n\n\t\tconst attr = morphTargets[ key ];\n\t\tif ( attr.isInterleavedBufferAttribute ) {\n\n\t\t\tif ( ! attrMap.has( attr ) ) {\n\n\t\t\t\tattrMap.set( attr, deinterleaveAttribute( attr ) );\n\n\t\t\t}\n\n\t\t\tmorphTargets[ key ] = attrMap.get( attr );\n\n\t\t}\n\n\t}\n\n}\n\n/**\n * @param {Array<BufferGeometry>} geometry\n * @return {number}\n */\nfunction estimateBytesUsed( geometry ) {\n\n\t// Return the estimated memory used by this geometry in bytes\n\t// Calculate using itemSize, count, and BYTES_PER_ELEMENT to account\n\t// for InterleavedBufferAttributes.\n\tlet mem = 0;\n\tfor ( const name in geometry.attributes ) {\n\n\t\tconst attr = geometry.getAttribute( name );\n\t\tmem += attr.count * attr.itemSize * attr.array.BYTES_PER_ELEMENT;\n\n\t}\n\n\tconst indices = geometry.getIndex();\n\tmem += indices ? indices.count * indices.itemSize * indices.array.BYTES_PER_ELEMENT : 0;\n\treturn mem;\n\n}\n\n/**\n * @param {BufferGeometry} geometry\n * @param {number} tolerance\n * @return {BufferGeometry}\n */\nfunction mergeVertices( geometry, tolerance = 1e-4 ) {\n\n\ttolerance = Math.max( tolerance, Number.EPSILON );\n\n\t// Generate an index buffer if the geometry doesn't have one, or optimize it\n\t// if it's already available.\n\tconst hashToIndex = {};\n\tconst indices = geometry.getIndex();\n\tconst positions = geometry.getAttribute( 'position' );\n\tconst vertexCount = indices ? indices.count : positions.count;\n\n\t// next value for triangle indices\n\tlet nextIndex = 0;\n\n\t// attributes and new attribute arrays\n\tconst attributeNames = Object.keys( geometry.attributes );\n\tconst tmpAttributes = {};\n\tconst tmpMorphAttributes = {};\n\tconst newIndices = [];\n\tconst getters = [ 'getX', 'getY', 'getZ', 'getW' ];\n\tconst setters = [ 'setX', 'setY', 'setZ', 'setW' ];\n\n\t// Initialize the arrays, allocating space conservatively. Extra\n\t// space will be trimmed in the last step.\n\tfor ( let i = 0, l = attributeNames.length; i < l; i ++ ) {\n\n\t\tconst name = attributeNames[ i ];\n\t\tconst attr = geometry.attributes[ name ];\n\n\t\ttmpAttributes[ name ] = new BufferAttribute(\n\t\t\tnew attr.array.constructor( attr.count * attr.itemSize ),\n\t\t\tattr.itemSize,\n\t\t\tattr.normalized\n\t\t);\n\n\t\tconst morphAttr = geometry.morphAttributes[ name ];\n\t\tif ( morphAttr ) {\n\n\t\t\ttmpMorphAttributes[ name ] = new BufferAttribute(\n\t\t\t\tnew morphAttr.array.constructor( morphAttr.count * morphAttr.itemSize ),\n\t\t\t\tmorphAttr.itemSize,\n\t\t\t\tmorphAttr.normalized\n\t\t\t);\n\n\t\t}\n\n\t}\n\n\t// convert the error tolerance to an amount of decimal places to truncate to\n\tconst decimalShift = Math.log10( 1 / tolerance );\n\tconst shiftMultiplier = Math.pow( 10, decimalShift );\n\tfor ( let i = 0; i < vertexCount; i ++ ) {\n\n\t\tconst index = indices ? indices.getX( i ) : i;\n\n\t\t// Generate a hash for the vertex attributes at the current index 'i'\n\t\tlet hash = '';\n\t\tfor ( let j = 0, l = attributeNames.length; j < l; j ++ ) {\n\n\t\t\tconst name = attributeNames[ j ];\n\t\t\tconst attribute = geometry.getAttribute( name );\n\t\t\tconst itemSize = attribute.itemSize;\n\n\t\t\tfor ( let k = 0; k < itemSize; k ++ ) {\n\n\t\t\t\t// double tilde truncates the decimal value\n\t\t\t\thash += `${ ~ ~ ( attribute[ getters[ k ] ]( index ) * shiftMultiplier ) },`;\n\n\t\t\t}\n\n\t\t}\n\n\t\t// Add another reference to the vertex if it's already\n\t\t// used by another index\n\t\tif ( hash in hashToIndex ) {\n\n\t\t\tnewIndices.push( hashToIndex[ hash ] );\n\n\t\t} else {\n\n\t\t\t// copy data to the new index in the temporary attributes\n\t\t\tfor ( let j = 0, l = attributeNames.length; j < l; j ++ ) {\n\n\t\t\t\tconst name = attributeNames[ j ];\n\t\t\t\tconst attribute = geometry.getAttribute( name );\n\t\t\t\tconst morphAttr = geometry.morphAttributes[ name ];\n\t\t\t\tconst itemSize = attribute.itemSize;\n\t\t\t\tconst newarray = tmpAttributes[ name ];\n\t\t\t\tconst newMorphArrays = tmpMorphAttributes[ name ];\n\n\t\t\t\tfor ( let k = 0; k < itemSize; k ++ ) {\n\n\t\t\t\t\tconst getterFunc = getters[ k ];\n\t\t\t\t\tconst setterFunc = setters[ k ];\n\t\t\t\t\tnewarray[ setterFunc ]( nextIndex, attribute[ getterFunc ]( index ) );\n\n\t\t\t\t\tif ( morphAttr ) {\n\n\t\t\t\t\t\tfor ( let m = 0, ml = morphAttr.length; m < ml; m ++ ) {\n\n\t\t\t\t\t\t\tnewMorphArrays[ m ][ setterFunc ]( nextIndex, morphAttr[ m ][ getterFunc ]( index ) );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\thashToIndex[ hash ] = nextIndex;\n\t\t\tnewIndices.push( nextIndex );\n\t\t\tnextIndex ++;\n\n\t\t}\n\n\t}\n\n\t// generate result BufferGeometry\n\tconst result = geometry.clone();\n\tfor ( const name in geometry.attributes ) {\n\n\t\tconst tmpAttribute = tmpAttributes[ name ];\n\n\t\tresult.setAttribute( name, new BufferAttribute(\n\t\t\ttmpAttribute.array.slice( 0, nextIndex * tmpAttribute.itemSize ),\n\t\t\ttmpAttribute.itemSize,\n\t\t\ttmpAttribute.normalized,\n\t\t) );\n\n\t\tif ( ! ( name in tmpMorphAttributes ) ) continue;\n\n\t\tfor ( let j = 0; j < tmpMorphAttributes[ name ].length; j ++ ) {\n\n\t\t\tconst tmpMorphAttribute = tmpMorphAttributes[ name ][ j ];\n\n\t\t\tresult.morphAttributes[ name ][ j ] = new BufferAttribute(\n\t\t\t\ttmpMorphAttribute.array.slice( 0, nextIndex * tmpMorphAttribute.itemSize ),\n\t\t\t\ttmpMorphAttribute.itemSize,\n\t\t\t\ttmpMorphAttribute.normalized,\n\t\t\t);\n\n\t\t}\n\n\t}\n\n\t// indices\n\n\tresult.setIndex( newIndices );\n\n\treturn result;\n\n}\n\n/**\n * @param {BufferGeometry} geometry\n * @param {number} drawMode\n * @return {BufferGeometry}\n */\nfunction toTrianglesDrawMode( geometry, drawMode ) {\n\n\tif ( drawMode === TrianglesDrawMode ) {\n\n\t\tconsole.warn( 'THREE.BufferGeometryUtils.toTrianglesDrawMode(): Geometry already defined as triangles.' );\n\t\treturn geometry;\n\n\t}\n\n\tif ( drawMode === TriangleFanDrawMode || drawMode === TriangleStripDrawMode ) {\n\n\t\tlet index = geometry.getIndex();\n\n\t\t// generate index if not present\n\n\t\tif ( index === null ) {\n\n\t\t\tconst indices = [];\n\n\t\t\tconst position = geometry.getAttribute( 'position' );\n\n\t\t\tif ( position !== undefined ) {\n\n\t\t\t\tfor ( let i = 0; i < position.count; i ++ ) {\n\n\t\t\t\t\tindices.push( i );\n\n\t\t\t\t}\n\n\t\t\t\tgeometry.setIndex( indices );\n\t\t\t\tindex = geometry.getIndex();\n\n\t\t\t} else {\n\n\t\t\t\tconsole.error( 'THREE.BufferGeometryUtils.toTrianglesDrawMode(): Undefined position attribute. Processing not possible.' );\n\t\t\t\treturn geometry;\n\n\t\t\t}\n\n\t\t}\n\n\t\t//\n\n\t\tconst numberOfTriangles = index.count - 2;\n\t\tconst newIndices = [];\n\n\t\tif ( drawMode === TriangleFanDrawMode ) {\n\n\t\t\t// gl.TRIANGLE_FAN\n\n\t\t\tfor ( let i = 1; i <= numberOfTriangles; i ++ ) {\n\n\t\t\t\tnewIndices.push( index.getX( 0 ) );\n\t\t\t\tnewIndices.push( index.getX( i ) );\n\t\t\t\tnewIndices.push( index.getX( i + 1 ) );\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\t// gl.TRIANGLE_STRIP\n\n\t\t\tfor ( let i = 0; i < numberOfTriangles; i ++ ) {\n\n\t\t\t\tif ( i % 2 === 0 ) {\n\n\t\t\t\t\tnewIndices.push( index.getX( i ) );\n\t\t\t\t\tnewIndices.push( index.getX( i + 1 ) );\n\t\t\t\t\tnewIndices.push( index.getX( i + 2 ) );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tnewIndices.push( index.getX( i + 2 ) );\n\t\t\t\t\tnewIndices.push( index.getX( i + 1 ) );\n\t\t\t\t\tnewIndices.push( index.getX( i ) );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( ( newIndices.length / 3 ) !== numberOfTriangles ) {\n\n\t\t\tconsole.error( 'THREE.BufferGeometryUtils.toTrianglesDrawMode(): Unable to generate correct amount of triangles.' );\n\n\t\t}\n\n\t\t// build final geometry\n\n\t\tconst newGeometry = geometry.clone();\n\t\tnewGeometry.setIndex( newIndices );\n\t\tnewGeometry.clearGroups();\n\n\t\treturn newGeometry;\n\n\t} else {\n\n\t\tconsole.error( 'THREE.BufferGeometryUtils.toTrianglesDrawMode(): Unknown draw mode:', drawMode );\n\t\treturn geometry;\n\n\t}\n\n}\n\n/**\n * Calculates the morphed attributes of a morphed/skinned BufferGeometry.\n * Helpful for Raytracing or Decals.\n * @param {Mesh | Line | Points} object An instance of Mesh, Line or Points.\n * @return {Object} An Object with original position/normal attributes and morphed ones.\n */\nfunction computeMorphedAttributes( object ) {\n\n\tconst _vA = new Vector3();\n\tconst _vB = new Vector3();\n\tconst _vC = new Vector3();\n\n\tconst _tempA = new Vector3();\n\tconst _tempB = new Vector3();\n\tconst _tempC = new Vector3();\n\n\tconst _morphA = new Vector3();\n\tconst _morphB = new Vector3();\n\tconst _morphC = new Vector3();\n\n\tfunction _calculateMorphedAttributeData(\n\t\tobject,\n\t\tattribute,\n\t\tmorphAttribute,\n\t\tmorphTargetsRelative,\n\t\ta,\n\t\tb,\n\t\tc,\n\t\tmodifiedAttributeArray\n\t) {\n\n\t\t_vA.fromBufferAttribute( attribute, a );\n\t\t_vB.fromBufferAttribute( attribute, b );\n\t\t_vC.fromBufferAttribute( attribute, c );\n\n\t\tconst morphInfluences = object.morphTargetInfluences;\n\n\t\tif ( morphAttribute && morphInfluences ) {\n\n\t\t\t_morphA.set( 0, 0, 0 );\n\t\t\t_morphB.set( 0, 0, 0 );\n\t\t\t_morphC.set( 0, 0, 0 );\n\n\t\t\tfor ( let i = 0, il = morphAttribute.length; i < il; i ++ ) {\n\n\t\t\t\tconst influence = morphInfluences[ i ];\n\t\t\t\tconst morph = morphAttribute[ i ];\n\n\t\t\t\tif ( influence === 0 ) continue;\n\n\t\t\t\t_tempA.fromBufferAttribute( morph, a );\n\t\t\t\t_tempB.fromBufferAttribute( morph, b );\n\t\t\t\t_tempC.fromBufferAttribute( morph, c );\n\n\t\t\t\tif ( morphTargetsRelative ) {\n\n\t\t\t\t\t_morphA.addScaledVector( _tempA, influence );\n\t\t\t\t\t_morphB.addScaledVector( _tempB, influence );\n\t\t\t\t\t_morphC.addScaledVector( _tempC, influence );\n\n\t\t\t\t} else {\n\n\t\t\t\t\t_morphA.addScaledVector( _tempA.sub( _vA ), influence );\n\t\t\t\t\t_morphB.addScaledVector( _tempB.sub( _vB ), influence );\n\t\t\t\t\t_morphC.addScaledVector( _tempC.sub( _vC ), influence );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t_vA.add( _morphA );\n\t\t\t_vB.add( _morphB );\n\t\t\t_vC.add( _morphC );\n\n\t\t}\n\n\t\tif ( object.isSkinnedMesh ) {\n\n\t\t\tobject.applyBoneTransform( a, _vA );\n\t\t\tobject.applyBoneTransform( b, _vB );\n\t\t\tobject.applyBoneTransform( c, _vC );\n\n\t\t}\n\n\t\tmodifiedAttributeArray[ a * 3 + 0 ] = _vA.x;\n\t\tmodifiedAttributeArray[ a * 3 + 1 ] = _vA.y;\n\t\tmodifiedAttributeArray[ a * 3 + 2 ] = _vA.z;\n\t\tmodifiedAttributeArray[ b * 3 + 0 ] = _vB.x;\n\t\tmodifiedAttributeArray[ b * 3 + 1 ] = _vB.y;\n\t\tmodifiedAttributeArray[ b * 3 + 2 ] = _vB.z;\n\t\tmodifiedAttributeArray[ c * 3 + 0 ] = _vC.x;\n\t\tmodifiedAttributeArray[ c * 3 + 1 ] = _vC.y;\n\t\tmodifiedAttributeArray[ c * 3 + 2 ] = _vC.z;\n\n\t}\n\n\tconst geometry = object.geometry;\n\tconst material = object.material;\n\n\tlet a, b, c;\n\tconst index = geometry.index;\n\tconst positionAttribute = geometry.attributes.position;\n\tconst morphPosition = geometry.morphAttributes.position;\n\tconst morphTargetsRelative = geometry.morphTargetsRelative;\n\tconst normalAttribute = geometry.attributes.normal;\n\tconst morphNormal = geometry.morphAttributes.position;\n\n\tconst groups = geometry.groups;\n\tconst drawRange = geometry.drawRange;\n\tlet i, j, il, jl;\n\tlet group;\n\tlet start, end;\n\n\tconst modifiedPosition = new Float32Array( positionAttribute.count * positionAttribute.itemSize );\n\tconst modifiedNormal = new Float32Array( normalAttribute.count * normalAttribute.itemSize );\n\n\tif ( index !== null ) {\n\n\t\t// indexed buffer geometry\n\n\t\tif ( Array.isArray( material ) ) {\n\n\t\t\tfor ( i = 0, il = groups.length; i < il; i ++ ) {\n\n\t\t\t\tgroup = groups[ i ];\n\n\t\t\t\tstart = Math.max( group.start, drawRange.start );\n\t\t\t\tend = Math.min( ( group.start + group.count ), ( drawRange.start + drawRange.count ) );\n\n\t\t\t\tfor ( j = start, jl = end; j < jl; j += 3 ) {\n\n\t\t\t\t\ta = index.getX( j );\n\t\t\t\t\tb = index.getX( j + 1 );\n\t\t\t\t\tc = index.getX( j + 2 );\n\n\t\t\t\t\t_calculateMorphedAttributeData(\n\t\t\t\t\t\tobject,\n\t\t\t\t\t\tpositionAttribute,\n\t\t\t\t\t\tmorphPosition,\n\t\t\t\t\t\tmorphTargetsRelative,\n\t\t\t\t\t\ta, b, c,\n\t\t\t\t\t\tmodifiedPosition\n\t\t\t\t\t);\n\n\t\t\t\t\t_calculateMorphedAttributeData(\n\t\t\t\t\t\tobject,\n\t\t\t\t\t\tnormalAttribute,\n\t\t\t\t\t\tmorphNormal,\n\t\t\t\t\t\tmorphTargetsRelative,\n\t\t\t\t\t\ta, b, c,\n\t\t\t\t\t\tmodifiedNormal\n\t\t\t\t\t);\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\tstart = Math.max( 0, drawRange.start );\n\t\t\tend = Math.min( index.count, ( drawRange.start + drawRange.count ) );\n\n\t\t\tfor ( i = start, il = end; i < il; i += 3 ) {\n\n\t\t\t\ta = index.getX( i );\n\t\t\t\tb = index.getX( i + 1 );\n\t\t\t\tc = index.getX( i + 2 );\n\n\t\t\t\t_calculateMorphedAttributeData(\n\t\t\t\t\tobject,\n\t\t\t\t\tpositionAttribute,\n\t\t\t\t\tmorphPosition,\n\t\t\t\t\tmorphTargetsRelative,\n\t\t\t\t\ta, b, c,\n\t\t\t\t\tmodifiedPosition\n\t\t\t\t);\n\n\t\t\t\t_calculateMorphedAttributeData(\n\t\t\t\t\tobject,\n\t\t\t\t\tnormalAttribute,\n\t\t\t\t\tmorphNormal,\n\t\t\t\t\tmorphTargetsRelative,\n\t\t\t\t\ta, b, c,\n\t\t\t\t\tmodifiedNormal\n\t\t\t\t);\n\n\t\t\t}\n\n\t\t}\n\n\t} else {\n\n\t\t// non-indexed buffer geometry\n\n\t\tif ( Array.isArray( material ) ) {\n\n\t\t\tfor ( i = 0, il = groups.length; i < il; i ++ ) {\n\n\t\t\t\tgroup = groups[ i ];\n\n\t\t\t\tstart = Math.max( group.start, drawRange.start );\n\t\t\t\tend = Math.min( ( group.start + group.count ), ( drawRange.start + drawRange.count ) );\n\n\t\t\t\tfor ( j = start, jl = end; j < jl; j += 3 ) {\n\n\t\t\t\t\ta = j;\n\t\t\t\t\tb = j + 1;\n\t\t\t\t\tc = j + 2;\n\n\t\t\t\t\t_calculateMorphedAttributeData(\n\t\t\t\t\t\tobject,\n\t\t\t\t\t\tpositionAttribute,\n\t\t\t\t\t\tmorphPosition,\n\t\t\t\t\t\tmorphTargetsRelative,\n\t\t\t\t\t\ta, b, c,\n\t\t\t\t\t\tmodifiedPosition\n\t\t\t\t\t);\n\n\t\t\t\t\t_calculateMorphedAttributeData(\n\t\t\t\t\t\tobject,\n\t\t\t\t\t\tnormalAttribute,\n\t\t\t\t\t\tmorphNormal,\n\t\t\t\t\t\tmorphTargetsRelative,\n\t\t\t\t\t\ta, b, c,\n\t\t\t\t\t\tmodifiedNormal\n\t\t\t\t\t);\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\tstart = Math.max( 0, drawRange.start );\n\t\t\tend = Math.min( positionAttribute.count, ( drawRange.start + drawRange.count ) );\n\n\t\t\tfor ( i = start, il = end; i < il; i += 3 ) {\n\n\t\t\t\ta = i;\n\t\t\t\tb = i + 1;\n\t\t\t\tc = i + 2;\n\n\t\t\t\t_calculateMorphedAttributeData(\n\t\t\t\t\tobject,\n\t\t\t\t\tpositionAttribute,\n\t\t\t\t\tmorphPosition,\n\t\t\t\t\tmorphTargetsRelative,\n\t\t\t\t\ta, b, c,\n\t\t\t\t\tmodifiedPosition\n\t\t\t\t);\n\n\t\t\t\t_calculateMorphedAttributeData(\n\t\t\t\t\tobject,\n\t\t\t\t\tnormalAttribute,\n\t\t\t\t\tmorphNormal,\n\t\t\t\t\tmorphTargetsRelative,\n\t\t\t\t\ta, b, c,\n\t\t\t\t\tmodifiedNormal\n\t\t\t\t);\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\tconst morphedPositionAttribute = new Float32BufferAttribute( modifiedPosition, 3 );\n\tconst morphedNormalAttribute = new Float32BufferAttribute( modifiedNormal, 3 );\n\n\treturn {\n\n\t\tpositionAttribute: positionAttribute,\n\t\tnormalAttribute: normalAttribute,\n\t\tmorphedPositionAttribute: morphedPositionAttribute,\n\t\tmorphedNormalAttribute: morphedNormalAttribute\n\n\t};\n\n}\n\nfunction mergeGroups( geometry ) {\n\n\tif ( geometry.groups.length === 0 ) {\n\n\t\tconsole.warn( 'THREE.BufferGeometryUtils.mergeGroups(): No groups are defined. Nothing to merge.' );\n\t\treturn geometry;\n\n\t}\n\n\tlet groups = geometry.groups;\n\n\t// sort groups by material index\n\n\tgroups = groups.sort( ( a, b ) => {\n\n\t\tif ( a.materialIndex !== b.materialIndex ) return a.materialIndex - b.materialIndex;\n\n\t\treturn a.start - b.start;\n\n\t} );\n\n\t// create index for non-indexed geometries\n\n\tif ( geometry.getIndex() === null ) {\n\n\t\tconst positionAttribute = geometry.getAttribute( 'position' );\n\t\tconst indices = [];\n\n\t\tfor ( let i = 0; i < positionAttribute.count; i += 3 ) {\n\n\t\t\tindices.push( i, i + 1, i + 2 );\n\n\t\t}\n\n\t\tgeometry.setIndex( indices );\n\n\t}\n\n\t// sort index\n\n\tconst index = geometry.getIndex();\n\n\tconst newIndices = [];\n\n\tfor ( let i = 0; i < groups.length; i ++ ) {\n\n\t\tconst group = groups[ i ];\n\n\t\tconst groupStart = group.start;\n\t\tconst groupLength = groupStart + group.count;\n\n\t\tfor ( let j = groupStart; j < groupLength; j ++ ) {\n\n\t\t\tnewIndices.push( index.getX( j ) );\n\n\t\t}\n\n\t}\n\n\tgeometry.dispose(); // Required to force buffer recreation\n\tgeometry.setIndex( newIndices );\n\n\t// update groups indices\n\n\tlet start = 0;\n\n\tfor ( let i = 0; i < groups.length; i ++ ) {\n\n\t\tconst group = groups[ i ];\n\n\t\tgroup.start = start;\n\t\tstart += group.count;\n\n\t}\n\n\t// merge groups\n\n\tlet currentGroup = groups[ 0 ];\n\n\tgeometry.groups = [ currentGroup ];\n\n\tfor ( let i = 1; i < groups.length; i ++ ) {\n\n\t\tconst group = groups[ i ];\n\n\t\tif ( currentGroup.materialIndex === group.materialIndex ) {\n\n\t\t\tcurrentGroup.count += group.count;\n\n\t\t} else {\n\n\t\t\tcurrentGroup = group;\n\t\t\tgeometry.groups.push( currentGroup );\n\n\t\t}\n\n\t}\n\n\treturn geometry;\n\n}\n\n\n// Creates a new, non-indexed geometry with smooth normals everywhere except faces that meet at\n// an angle greater than the crease angle.\nfunction toCreasedNormals( geometry, creaseAngle = Math.PI / 3 /* 60 degrees */ ) {\n\n\tconst creaseDot = Math.cos( creaseAngle );\n\tconst hashMultiplier = ( 1 + 1e-10 ) * 1e2;\n\n\t// reusable vertors\n\tconst verts = [ new Vector3(), new Vector3(), new Vector3() ];\n\tconst tempVec1 = new Vector3();\n\tconst tempVec2 = new Vector3();\n\tconst tempNorm = new Vector3();\n\tconst tempNorm2 = new Vector3();\n\n\t// hashes a vector\n\tfunction hashVertex( v ) {\n\n\t\tconst x = ~ ~ ( v.x * hashMultiplier );\n\t\tconst y = ~ ~ ( v.y * hashMultiplier );\n\t\tconst z = ~ ~ ( v.z * hashMultiplier );\n\t\treturn `${x},${y},${z}`;\n\n\t}\n\n\tconst resultGeometry = geometry.toNonIndexed();\n\tconst posAttr = resultGeometry.attributes.position;\n\tconst vertexMap = {};\n\n\t// find all the normals shared by commonly located vertices\n\tfor ( let i = 0, l = posAttr.count / 3; i < l; i ++ ) {\n\n\t\tconst i3 = 3 * i;\n\t\tconst a = verts[ 0 ].fromBufferAttribute( posAttr, i3 + 0 );\n\t\tconst b = verts[ 1 ].fromBufferAttribute( posAttr, i3 + 1 );\n\t\tconst c = verts[ 2 ].fromBufferAttribute( posAttr, i3 + 2 );\n\n\t\ttempVec1.subVectors( c, b );\n\t\ttempVec2.subVectors( a, b );\n\n\t\t// add the normal to the map for all vertices\n\t\tconst normal = new Vector3().crossVectors( tempVec1, tempVec2 ).normalize();\n\t\tfor ( let n = 0; n < 3; n ++ ) {\n\n\t\t\tconst vert = verts[ n ];\n\t\t\tconst hash = hashVertex( vert );\n\t\t\tif ( ! ( hash in vertexMap ) ) {\n\n\t\t\t\tvertexMap[ hash ] = [];\n\n\t\t\t}\n\n\t\t\tvertexMap[ hash ].push( normal );\n\n\t\t}\n\n\t}\n\n\t// average normals from all vertices that share a common location if they are within the\n\t// provided crease threshold\n\tconst normalArray = new Float32Array( posAttr.count * 3 );\n\tconst normAttr = new BufferAttribute( normalArray, 3, false );\n\tfor ( let i = 0, l = posAttr.count / 3; i < l; i ++ ) {\n\n\t\t// get the face normal for this vertex\n\t\tconst i3 = 3 * i;\n\t\tconst a = verts[ 0 ].fromBufferAttribute( posAttr, i3 + 0 );\n\t\tconst b = verts[ 1 ].fromBufferAttribute( posAttr, i3 + 1 );\n\t\tconst c = verts[ 2 ].fromBufferAttribute( posAttr, i3 + 2 );\n\n\t\ttempVec1.subVectors( c, b );\n\t\ttempVec2.subVectors( a, b );\n\n\t\ttempNorm.crossVectors( tempVec1, tempVec2 ).normalize();\n\n\t\t// average all normals that meet the threshold and set the normal value\n\t\tfor ( let n = 0; n < 3; n ++ ) {\n\n\t\t\tconst vert = verts[ n ];\n\t\t\tconst hash = hashVertex( vert );\n\t\t\tconst otherNormals = vertexMap[ hash ];\n\t\t\ttempNorm2.set( 0, 0, 0 );\n\n\t\t\tfor ( let k = 0, lk = otherNormals.length; k < lk; k ++ ) {\n\n\t\t\t\tconst otherNorm = otherNormals[ k ];\n\t\t\t\tif ( tempNorm.dot( otherNorm ) > creaseDot ) {\n\n\t\t\t\t\ttempNorm2.add( otherNorm );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\ttempNorm2.normalize();\n\t\t\tnormAttr.setXYZ( i3 + n, tempNorm2.x, tempNorm2.y, tempNorm2.z );\n\n\t\t}\n\n\t}\n\n\tresultGeometry.setAttribute( 'normal', normAttr );\n\treturn resultGeometry;\n\n}\n\nfunction mergeBufferGeometries( geometries, useGroups = false ) {\n\n\tconsole.warn( 'THREE.BufferGeometryUtils: mergeBufferGeometries() has been renamed to mergeGeometries().' ); // @deprecated, r151\n\treturn mergeGeometries( geometries, useGroups );\n\n}\n\nfunction mergeBufferAttributes( attributes ) {\n\n\tconsole.warn( 'THREE.BufferGeometryUtils: mergeBufferAttributes() has been renamed to mergeAttributes().' ); // @deprecated, r151\n\treturn mergeAttributes( attributes );\n\n}\n\nexport {\n\tcomputeMikkTSpaceTangents,\n\tmergeGeometries,\n\tmergeBufferGeometries,\n\tmergeAttributes,\n\tmergeBufferAttributes,\n\tinterleaveAttributes,\n\testimateBytesUsed,\n\tmergeVertices,\n\ttoTrianglesDrawMode,\n\tcomputeMorphedAttributes,\n\tmergeGroups,\n\ttoCreasedNormals\n};\n", "import { BufferGeometry, Material, Mesh, Object3D, Scene } from 'three';\r\nimport { IFCManager } from './IFCManager';\r\nimport { BaseSubsetConfig } from '../BaseDefinitions';\r\n\r\nconst nullIfcManagerErrorMessage = 'IfcManager is null!';\r\n\r\n/**\r\n * Represents an IFC model. This object is returned by the `IFCLoader` after loading an IFC.\r\n * @geometry `THREE.Buffergeometry`, see Three.js documentation.\r\n * @materials `THREE.Material[]`, see Three.js documentation.\r\n * @manager contains all the logic to work with IFC.\r\n */\r\nexport class IFCModel extends Mesh {\r\n\r\n    private static modelIdCounter = 0;\r\n\r\n    static dispose() {\r\n        IFCModel.modelIdCounter = 0;\r\n    }\r\n\r\n    modelID = IFCModel.modelIdCounter++;\r\n    ifcManager: IFCManager | null = null;\r\n\r\n    /**\r\n     * @deprecated `IfcModel` is already a mesh; you can place it in the scene directly.\r\n     */\r\n    mesh = this;\r\n\r\n    setIFCManager(manager: IFCManager) {\r\n        this.ifcManager = manager;\r\n    }\r\n\r\n    /**\r\n     * @deprecated Use `IfcModel.ifcManager.setWasmPath` instead.\r\n     *\r\n     * Sets the relative path of web-ifc.wasm file in the project.\r\n     * Beware: you **must** serve this file in your page; this means\r\n     * that you have to copy this files from *node_modules/web-ifc*\r\n     * to your deployment directory.\r\n     *\r\n     * If you don't use this methods,\r\n     * IFC.js assumes that you are serving it in the root directory.\r\n     *\r\n     * Example if web-ifc.wasm is in dist/wasmDir:\r\n     * `ifcLoader.setWasmPath(\"dist/wasmDir/\");`\r\n     *\r\n     * @path Relative path to web-ifc.wasm.\r\n     */\r\n    setWasmPath(path: string) {\r\n        if (this.ifcManager === null) throw new Error(nullIfcManagerErrorMessage);\r\n        this.ifcManager.setWasmPath(path);\r\n    }\r\n\r\n    /**\r\n     * @deprecated Use `IfcModel.ifcManager.close` instead.\r\n     *\r\n     * Closes the specified model and deletes it from the [scene](https://threejs.org/docs/#api/en/scenes/Scene).\r\n     * @scene Scene where the model is (if it's located in a scene).\r\n     */\r\n    close(scene?: Scene) {\r\n        if (this.ifcManager === null) throw new Error(nullIfcManagerErrorMessage);\r\n        this.ifcManager.close(this.modelID, scene);\r\n    }\r\n\r\n    /**\r\n     * @deprecated Use `IfcModel.ifcManager.getExpressId` instead.\r\n     *\r\n     * Gets the **Express ID** to which the given face belongs.\r\n     * This ID uniquely identifies this entity within this IFC file.\r\n     * @geometry The geometry of the IFC model.\r\n     * @faceIndex The index of the face of a geometry.You can easily get this index using the [Raycaster](https://threejs.org/docs/#api/en/core/Raycaster).\r\n     */\r\n    getExpressId(geometry: BufferGeometry, faceIndex: number) {\r\n        if (this.ifcManager === null) throw new Error(nullIfcManagerErrorMessage);\r\n        return this.ifcManager.getExpressId(geometry, faceIndex);\r\n    }\r\n\r\n    /**\r\n     * @deprecated Use `IfcModel.ifcManager.getAllItemsOfType` instead.\r\n     *\r\n     * Returns all items of the specified type. You can import\r\n     * the types from *web-ifc*.\r\n     *\r\n     * Example to get all the standard walls of a project:\r\n     * ```js\r\n     * import { IFCWALLSTANDARDCASE } from 'web-ifc';\r\n     * const walls = ifcLoader.getAllItemsOfType(IFCWALLSTANDARDCASE);\r\n     * ```\r\n     * @type The type of IFC items to get.\r\n     * @verbose If false (default), this only gets IDs. If true, this also gets the native properties of all the fetched items.\r\n     */\r\n    getAllItemsOfType(type: number, verbose: boolean) {\r\n        if (this.ifcManager === null) throw new Error(nullIfcManagerErrorMessage);\r\n        return this.ifcManager.getAllItemsOfType(this.modelID, type, verbose);\r\n    }\r\n\r\n    /**\r\n     * @deprecated Use `IfcModel.ifcManager.getItemProperties` instead.\r\n     *\r\n     * Gets the native properties of the given element.\r\n     * @id Express ID of the element.\r\n     * @recursive Wether you want to get the information of the referenced elements recursively.\r\n     */\r\n    getItemProperties(id: number, recursive = false) {\r\n        if (this.ifcManager === null) throw new Error(nullIfcManagerErrorMessage);\r\n        return this.ifcManager.getItemProperties(this.modelID, id, recursive);\r\n    }\r\n\r\n    /**\r\n     * @deprecated Use `IfcModel.ifcManager.getPropertySets` instead.\r\n     *\r\n     * Gets the [property sets](https://standards.buildingsmart.org/IFC/DEV/IFC4_2/FINAL/HTML/schema/ifckernel/lexical/ifcpropertyset.htm)\r\n     * assigned to the given element.\r\n     * @id Express ID of the element.\r\n     * @recursive If true, this gets the native properties of the referenced elements recursively.\r\n     */\r\n    getPropertySets(id: number, recursive = false) {\r\n        if (this.ifcManager === null) throw new Error(nullIfcManagerErrorMessage);\r\n        return this.ifcManager.getPropertySets(this.modelID, id, recursive);\r\n    }\r\n\r\n    /**\r\n     * @deprecated Use `IfcModel.ifcManager.getTypeProperties` instead.\r\n     *\r\n     * Gets the properties of the type assigned to the element.\r\n     * For example, if applied to a wall (IfcWall), this would get back the information\r\n     * contained in the IfcWallType assigned to it, if any.\r\n     * @id Express ID of the element.\r\n     * @recursive If true, this gets the native properties of the referenced elements recursively.\r\n     */\r\n    getTypeProperties(id: number, recursive = false) {\r\n        if (this.ifcManager === null) throw new Error(nullIfcManagerErrorMessage);\r\n        return this.ifcManager.getTypeProperties(this.modelID, id, recursive);\r\n    }\r\n\r\n    /**\r\n     * @deprecated Use `IfcModel.ifcManager.getIfcType` instead.\r\n     *\r\n     * Gets the ifc type of the specified item.\r\n     * @id Express ID of the element.\r\n     */\r\n    getIfcType(id: number) {\r\n        if (this.ifcManager === null) throw new Error(nullIfcManagerErrorMessage);\r\n        return this.ifcManager.getIfcType(this.modelID, id);\r\n    }\r\n\r\n    /**\r\n     * @deprecated Use `IfcModel.ifcManager.getSpatialStructure` instead.\r\n     *\r\n     * Gets the spatial structure of the project. The\r\n     * [spatial structure](https://standards.buildingsmart.org/IFC/DEV/IFC4_2/FINAL/HTML/schema/ifcproductextension/lexical/ifcspatialstructureelement.htm)\r\n     * is the hierarchical structure that organizes every IFC project (all physical items\r\n     * are referenced to an element of the spatial structure). It is formed by\r\n     * one IfcProject that contains one or more IfcSites, that contain one or more\r\n     * IfcBuildings, that contain one or more IfcBuildingStoreys, that contain\r\n     * one or more IfcSpaces.\r\n     */\r\n    getSpatialStructure() {\r\n        if (this.ifcManager === null) throw new Error(nullIfcManagerErrorMessage);\r\n        return this.ifcManager.getSpatialStructure(this.modelID);\r\n    }\r\n\r\n    /**\r\n     * @deprecated Use `IfcModel.ifcManager.getSubset` instead.\r\n     *\r\n     * Gets the mesh of the subset with the specified [material](https://threejs.org/docs/#api/en/materials/Material).\r\n     * If no material is given, this returns the subset with the original materials.\r\n     * @material Material assigned to the subset, if any.\r\n     */\r\n    getSubset(material?: Material) {\r\n        if (this.ifcManager === null) throw new Error(nullIfcManagerErrorMessage);\r\n        return this.ifcManager.getSubset(this.modelID, material);\r\n    }\r\n\r\n    /**\r\n     * @deprecated Use `IfcModel.ifcManager.removeSubset` instead.\r\n     *\r\n     * Removes the specified subset.\r\n     * @parent The parent where the subset is (can be any `THREE.Object3D`).\r\n     * @material Material assigned to the subset, if any.\r\n     */\r\n    removeSubset(material?: Material, customID?: string) {\r\n        if (this.ifcManager === null) throw new Error(nullIfcManagerErrorMessage);\r\n        this.ifcManager.removeSubset(this.modelID, material, customID);\r\n    }\r\n\r\n    /**\r\n     * @deprecated Use `IfcModel.ifcManager.createSubset` instead.\r\n     *\r\n     * Creates a new geometric subset.\r\n     * @config A configuration object with the following options:\r\n     * - **scene**: `THREE.Object3D` where the model is located.\r\n     * - **ids**: Express IDs of the items of the model that will conform the subset.\r\n     * - **removePrevious**: Wether to remove the previous subset of this model with this material.\r\n     * - **material**: (optional) Wether to apply a material to the subset\r\n     */\r\n    createSubset(config: BaseSubsetConfig) {\r\n        if (this.ifcManager === null) throw new Error(nullIfcManagerErrorMessage);\r\n        const modelConfig = { ...config, modelID: this.modelID };\r\n        return this.ifcManager.createSubset(modelConfig);\r\n    }\r\n}\r\n", "//@ts-ignore\r\nimport {\r\n    PlacedGeometry,\r\n    Color as ifcColor,\r\n    IfcGeometry,\r\n    IFCSPACE,\r\n    FlatMesh,\r\n    IFCOPENINGELEMENT,\r\n    IFCPRODUCTDEFINITIONSHAPE\r\n} from 'web-ifc';\r\nimport { IfcState, IfcMesh } from '../BaseDefinitions';\r\nimport {\r\n    Color,\r\n    MeshLambertMaterial,\r\n    DoubleSide,\r\n    Matrix4,\r\n    BufferGeometry,\r\n    BufferAttribute,\r\n    Mesh\r\n} from 'three';\r\nimport { mergeBufferGeometries } from 'three/examples/jsm/utils/BufferGeometryUtils';\r\nimport { BvhManager } from './BvhManager';\r\nimport { IFCModel } from './IFCModel';\r\n\r\nexport interface ParserProgress {\r\n    loaded: number;\r\n    total: number;\r\n}\r\n\r\nexport interface OptionalCategories {\r\n    [category: number]: boolean\r\n}\r\n\r\nexport interface ParserAPI {\r\n    parse(buffer: any, coordinationMatrix?: number[]): Promise<IFCModel>;\r\n\r\n    getAndClearErrors(_modelId: number): void;\r\n\r\n    setupOptionalCategories(config: OptionalCategories): Promise<void>;\r\n\r\n    optionalCategories: OptionalCategories;\r\n}\r\n\r\nexport interface GeometriesByMaterial {\r\n    [materialID: string]: {\r\n        material: MeshLambertMaterial,\r\n        geometries: BufferGeometry[]\r\n    }\r\n}\r\n\r\n/**\r\n * Reads all the geometry of the IFC file and generates an optimized `THREE.Mesh`.\r\n */\r\nexport class IFCParser implements ParserAPI {\r\n    loadedModels = 0;\r\n\r\n    optionalCategories: OptionalCategories = {\r\n        [IFCSPACE]: true,\r\n        [IFCOPENINGELEMENT]: false\r\n    };\r\n\r\n    private geometriesByMaterials: GeometriesByMaterial = {};\r\n\r\n    private loadingState = {\r\n        total: 0,\r\n        current: 0,\r\n        step: 0.1\r\n    }\r\n\r\n    // Represents the index of the model in webIfcAPI\r\n    private currentWebIfcID = -1;\r\n    // When using JSON data for optimization, webIfcAPI is reinitialized every time a model is loaded\r\n    // This means that currentID is always 0, while currentModelID is the real index of stored models\r\n    private currentModelID = -1;\r\n\r\n    // BVH is optional because when using workers we have to apply it in the main thread,\r\n    // once the model has been serialized and reconstructed\r\n    constructor(private state: IfcState, private BVH?: BvhManager) {\r\n    }\r\n\r\n    async setupOptionalCategories(config: OptionalCategories) {\r\n        this.optionalCategories = config;\r\n    }\r\n\r\n    async parse(buffer: any, coordinationMatrix?: number[]) {\r\n        if (this.state.api.wasmModule === undefined) await this.state.api.Init();\r\n        await this.newIfcModel(buffer);\r\n        this.loadedModels++;\r\n        if (coordinationMatrix) {\r\n            await this.state.api.SetGeometryTransformation(this.currentWebIfcID, coordinationMatrix);\r\n        }\r\n        return this.loadAllGeometry(this.currentWebIfcID);\r\n    }\r\n\r\n    getAndClearErrors(_modelId: number) {\r\n        // return this.state.api.GetAndClearErrors(modelId);\r\n    }\r\n\r\n    private notifyProgress(loaded: number, total: number) {\r\n        if (this.state.onProgress) this.state.onProgress({ loaded, total });\r\n    }\r\n\r\n    private async newIfcModel(buffer: any) {\r\n        const data = new Uint8Array(buffer);\r\n        this.currentWebIfcID = await this.state.api.OpenModel(data, this.state.webIfcSettings);\r\n        this.currentModelID = this.state.useJSON ? this.loadedModels : this.currentWebIfcID;\r\n        this.state.models[this.currentModelID] = {\r\n            modelID: this.currentModelID,\r\n            mesh: {} as IfcMesh,\r\n            types: {},\r\n            jsonData: {}\r\n        };\r\n    }\r\n\r\n    private async loadAllGeometry(modelID: number) {\r\n        this.addOptionalCategories(modelID);\r\n        await this.initializeLoadingState(modelID);\r\n\r\n        this.state.api.StreamAllMeshes(modelID, (mesh: FlatMesh) => {\r\n            this.updateLoadingState();\r\n            // only during the lifetime of this function call, the geometry is available in memory\r\n            this.streamMesh(modelID, mesh);\r\n        });\r\n\r\n        this.notifyLoadingEnded();\r\n        const geometries: BufferGeometry[] = [];\r\n        const materials: MeshLambertMaterial[] = [];\r\n\r\n        Object.keys(this.geometriesByMaterials).forEach((key) => {\r\n            const geometriesByMaterial = this.geometriesByMaterials[key].geometries;\r\n            const merged = mergeBufferGeometries(geometriesByMaterial);\r\n            materials.push(this.geometriesByMaterials[key].material);\r\n            geometries.push(merged);\r\n        });\r\n\r\n        const combinedGeometry = mergeBufferGeometries(geometries, true);\r\n        this.cleanUpGeometryMemory(geometries);\r\n        if (this.BVH) this.BVH.applyThreeMeshBVH(combinedGeometry);\r\n        const model = new IFCModel(combinedGeometry, materials);\r\n        this.state.models[this.currentModelID].mesh = model;\r\n        return model;\r\n    }\r\n\r\n    private async initializeLoadingState(modelID: number) {\r\n        const shapes = await this.state.api.GetLineIDsWithType(modelID, IFCPRODUCTDEFINITIONSHAPE);\r\n        this.loadingState.total = shapes.size();\r\n        this.loadingState.current = 0;\r\n        this.loadingState.step = 0.1;\r\n    }\r\n\r\n    private notifyLoadingEnded() {\r\n        this.notifyProgress(this.loadingState.total, this.loadingState.total);\r\n    }\r\n\r\n    private updateLoadingState() {\r\n        const realCurrentItem = Math.min(this.loadingState.current++, this.loadingState.total);\r\n        if(realCurrentItem / this.loadingState.total >= this.loadingState.step) {\r\n            const currentProgress = Math.ceil(this.loadingState.total * this.loadingState.step);\r\n            this.notifyProgress(currentProgress, this.loadingState.total);\r\n            this.loadingState.step += 0.1;\r\n        }\r\n    }\r\n\r\n    // Some categories (like IfcSpace and IfcOpeningElement) need to be set explicitly\r\n    private addOptionalCategories(modelID: number) {\r\n\r\n        const optionalTypes: number[] = [];\r\n\r\n        for (let key in this.optionalCategories) {\r\n            if (this.optionalCategories.hasOwnProperty(key)) {\r\n                const category = parseInt(key);\r\n                if (this.optionalCategories[category]) optionalTypes.push(category);\r\n            }\r\n        }\r\n\r\n        this.state.api.StreamAllMeshesWithTypes(this.currentWebIfcID, optionalTypes, (mesh: FlatMesh) => {\r\n            this.streamMesh(modelID, mesh);\r\n        });\r\n    }\r\n\r\n    private streamMesh(modelID: number, mesh: FlatMesh) {\r\n        const placedGeometries = mesh.geometries;\r\n        const size = placedGeometries.size();\r\n\r\n        for (let i = 0; i < size; i++) {\r\n            const placedGeometry = placedGeometries.get(i);\r\n            let itemMesh = this.getPlacedGeometry(modelID, mesh.expressID, placedGeometry);\r\n            let geom = itemMesh.geometry.applyMatrix4(itemMesh.matrix);\r\n            this.storeGeometryByMaterial(placedGeometry.color, geom);\r\n        }\r\n    }\r\n\r\n    private getPlacedGeometry(modelID: number, expressID: number, placedGeometry: PlacedGeometry) {\r\n        const geometry = this.getBufferGeometry(modelID, expressID, placedGeometry);\r\n        const mesh = new Mesh(geometry);\r\n        mesh.matrix = this.getMeshMatrix(placedGeometry.flatTransformation);\r\n        mesh.matrixAutoUpdate = false;\r\n        return mesh;\r\n    }\r\n\r\n    private getBufferGeometry(modelID: number, expressID: number, placedGeometry: PlacedGeometry) {\r\n        const geometry = this.state.api.GetGeometry(modelID, placedGeometry.geometryExpressID) as IfcGeometry;\r\n        const verts = this.state.api.GetVertexArray(geometry.GetVertexData(), geometry.GetVertexDataSize()) as Float32Array;\r\n        const indices = this.state.api.GetIndexArray(geometry.GetIndexData(), geometry.GetIndexDataSize()) as Uint32Array;\r\n        const buffer = this.ifcGeometryToBuffer(expressID, verts, indices);\r\n        //@ts-ignore\r\n        geometry.delete();\r\n        return buffer;\r\n    }\r\n\r\n    private storeGeometryByMaterial(color: ifcColor, geometry: BufferGeometry) {\r\n        let colID = `${color.x}${color.y}${color.z}${color.w}`;\r\n        if (this.geometriesByMaterials[colID]) {\r\n            this.geometriesByMaterials[colID].geometries.push(geometry);\r\n            return;\r\n        }\r\n\r\n        const col = new Color(color.x, color.y, color.z);\r\n        const material = new MeshLambertMaterial({ color: col, side: DoubleSide });\r\n        material.transparent = color.w !== 1;\r\n        if (material.transparent) material.opacity = color.w;\r\n        this.geometriesByMaterials[colID] = { material, geometries: [geometry] };\r\n    }\r\n\r\n    private getMeshMatrix(matrix: Array<number>) {\r\n        const mat = new Matrix4();\r\n        mat.fromArray(matrix);\r\n        return mat;\r\n    }\r\n\r\n    private ifcGeometryToBuffer(expressID: number, vertexData: Float32Array, indexData: Uint32Array) {\r\n        const geometry = new BufferGeometry();\r\n\r\n        const posFloats = new Float32Array(vertexData.length / 2);\r\n        const normFloats = new Float32Array(vertexData.length / 2);\r\n        const idAttribute = new Uint32Array(vertexData.length / 6);\r\n\r\n        for (let i = 0; i < vertexData.length; i += 6) {\r\n            posFloats[i / 2] = vertexData[i];\r\n            posFloats[i / 2 + 1] = vertexData[i + 1];\r\n            posFloats[i / 2 + 2] = vertexData[i + 2];\r\n\r\n            normFloats[i / 2] = vertexData[i + 3];\r\n            normFloats[i / 2 + 1] = vertexData[i + 4];\r\n            normFloats[i / 2 + 2] = vertexData[i + 5];\r\n\r\n            idAttribute[i / 6] = expressID;\r\n        }\r\n\r\n        geometry.setAttribute(\r\n            'position',\r\n            new BufferAttribute(posFloats, 3));\r\n        geometry.setAttribute(\r\n            'normal',\r\n            new BufferAttribute(normFloats, 3));\r\n        geometry.setAttribute(\r\n            'expressID',\r\n            new BufferAttribute(idAttribute, 1));\r\n\r\n        geometry.setIndex(new BufferAttribute(indexData, 1));\r\n        return geometry;\r\n    }\r\n\r\n    // Three.js geometry has to be manually deallocated\r\n    private cleanUpGeometryMemory(geometries: BufferGeometry[]) {\r\n        geometries.forEach(geometry => geometry.dispose());\r\n\r\n        Object.keys(this.geometriesByMaterials).forEach((materialID) => {\r\n            const geometriesByMaterial = this.geometriesByMaterials[materialID];\r\n            geometriesByMaterial.geometries.forEach(geometry => geometry.dispose());\r\n            geometriesByMaterial.geometries = [];\r\n            // @ts-ignore\r\n            geometriesByMaterial.material = null;\r\n        });\r\n        this.geometriesByMaterials = {};\r\n    }\r\n}\r\n", "import { IfcState } from '../../BaseDefinitions';\r\nimport { BufferAttribute, BufferGeometry, Material } from 'three';\r\n\r\n// The number array has the meaning: [start, end, start, end, start, end...]\r\nexport interface Indices {\r\n    [materialID: number]: number[]\r\n}\r\n\r\nexport interface IndexedGeometry extends BufferGeometry {\r\n    index: BufferAttribute;\r\n}\r\n\r\nexport interface Group {\r\n    start: number,\r\n    count: number,\r\n    materialIndex?: number\r\n}\r\n\r\nexport interface Items {\r\n    indexCache: Uint32Array,\r\n    map: Map<number, Indices>\r\n}\r\n\r\nexport interface IndicesMap {\r\n    [modelID: number]: {\r\n        indexCache: Uint32Array;\r\n        map: Map<number, Indices>;\r\n    }\r\n}\r\n\r\nexport class ItemsMap {\r\n\r\n    constructor(private state: IfcState) {\r\n    }\r\n\r\n    map: IndicesMap = {};\r\n\r\n    generateGeometryIndexMap(modelID: number) {\r\n        if (this.map[modelID]) return;\r\n        const geometry = this.getGeometry(modelID);\r\n        const items = this.newItemsMap(modelID, geometry);\r\n        for (const group of geometry.groups) {\r\n            this.fillItemsWithGroupInfo(group, geometry, items);\r\n        }\r\n    }\r\n\r\n    getSubsetID(modelID: number, material?: Material, customID = 'DEFAULT') {\r\n        const baseID = modelID;\r\n        const materialID = material ? material.uuid : 'DEFAULT';\r\n        return `${baseID} - ${materialID} - ${customID}`;\r\n    }\r\n\r\n    // Use this only for destroying the current IFCLoader instance\r\n    dispose() {\r\n        Object.values(this.map).forEach(model => {\r\n            (model.indexCache as any) = null;\r\n            (model.map as any) = null;\r\n        });\r\n\r\n        (this.map as any) = null;\r\n    }\r\n\r\n    private getGeometry(modelID: number) {\r\n        const geometry = this.state.models[modelID].mesh.geometry;\r\n        if (!geometry) throw new Error('Model without geometry.');\r\n        if (!geometry.index) throw new Error('Geometry must be indexed');\r\n        return geometry as IndexedGeometry;\r\n    }\r\n\r\n    private newItemsMap(modelID: number, geometry: IndexedGeometry) {\r\n        const startIndices = geometry.index.array as Uint32Array;\r\n        this.map[modelID] = {\r\n            indexCache: startIndices.slice(0, geometry.index.array.length),\r\n            map: new Map()\r\n        };\r\n        return this.map[modelID] as Items;\r\n    }\r\n\r\n    private fillItemsWithGroupInfo(group: Group, geometry: IndexedGeometry, items: Items) {\r\n        let prevExpressID = -1;\r\n\r\n        const materialIndex = group.materialIndex as number;\r\n        const materialStart = group.start;\r\n        const materialEnd = materialStart + group.count - 1;\r\n\r\n        let objectStart = -1;\r\n        let objectEnd = -1;\r\n\r\n        for (let i = materialStart; i <= materialEnd; i++) {\r\n            const index = geometry.index.array[i];\r\n            const bufferAttr = geometry.attributes.expressID as BufferAttribute;\r\n            const expressID = bufferAttr.array[index];\r\n\r\n            // First iteration\r\n            if (prevExpressID === -1) {\r\n                prevExpressID = expressID;\r\n                objectStart = i;\r\n            }\r\n\r\n            // It's the end of the material, which also means end of the object\r\n            const isEndOfMaterial = i === materialEnd;\r\n            if (isEndOfMaterial) {\r\n                const store = this.getMaterialStore(items.map, expressID, materialIndex);\r\n                store.push(objectStart, materialEnd);\r\n                break;\r\n            }\r\n\r\n            // Still going through the same object\r\n            if (prevExpressID === expressID) continue;\r\n\r\n            // New object starts; save previous object\r\n\r\n            // Store previous object\r\n            const store = this.getMaterialStore(items.map, prevExpressID, materialIndex);\r\n            objectEnd = i - 1;\r\n            store.push(objectStart, objectEnd);\r\n\r\n            // Get ready to process next object\r\n            prevExpressID = expressID;\r\n            objectStart = i;\r\n        }\r\n    }\r\n\r\n    private getMaterialStore(map: Map<number, Indices>, id: number, matIndex: number) {\r\n        // If this object wasn't store before, add it to the map\r\n        if (map.get(id) === undefined) {\r\n            map.set(id, {});\r\n        }\r\n        const storedIfcItem = map.get(id);\r\n        if (storedIfcItem === undefined) throw new Error('Geometry map generation error');\r\n\r\n        // If this material wasn't stored for this object before, add it to the object\r\n        if (storedIfcItem[matIndex] === undefined) {\r\n            storedIfcItem[matIndex] = [];\r\n        }\r\n        return storedIfcItem[matIndex];\r\n    }\r\n\r\n}", "export class SubsetUtils {\r\n\r\n    // If flatten, all indices are in the same array; otherwise, indices are split in subarrays by material\r\n    static getAllIndicesOfGroup(modelID: number, ids: number[], materialIndex: number, items: any, flatten = true) {\r\n        const indicesByGroup: any = [];\r\n        for (const expressID of ids) {\r\n            const entry = items.map.get(expressID);\r\n            if (!entry) continue;\r\n            const value = entry[materialIndex];\r\n            if (!value) continue;\r\n            SubsetUtils.getIndexChunk(value, indicesByGroup, materialIndex, items, flatten);\r\n        }\r\n        return indicesByGroup;\r\n    }\r\n\r\n    private static getIndexChunk(value: number[], indicesByGroup: any, materialIndex: number, items: any, flatten: boolean) {\r\n        const pairs = value.length / 2;\r\n        for (let pair = 0; pair < pairs; pair++) {\r\n            const pairIndex = pair * 2;\r\n            const start = value[pairIndex];\r\n            const end = value[pairIndex + 1];\r\n            for (let j = start; j <= end; j++) {\r\n                if(flatten) indicesByGroup.push(items.indexCache[j]);\r\n                else {\r\n                    if (!indicesByGroup[materialIndex]) indicesByGroup[materialIndex] = [];\r\n                    indicesByGroup[materialIndex].push(items.indexCache[j]);\r\n                }\r\n            }\r\n        }\r\n    }\r\n}", "import { BufferGeometry, Mesh } from 'three';\r\nimport { IfcState, SubsetConfig } from '../../BaseDefinitions';\r\nimport { IndexedGeometry, ItemsMap } from './ItemsMap';\r\nimport { Subset, Subsets } from './SubsetManager';\r\nimport { SubsetUtils } from './SubsetUtils';\r\nimport { BvhManager } from '../BvhManager';\r\n\r\nexport class SubsetCreator {\r\n\r\n    private tempIndex: number[] = [];\r\n\r\n    constructor(private state: IfcState, private items: ItemsMap, private subsets: Subsets, private BVH: BvhManager) {\r\n    }\r\n\r\n    createSubset(config: SubsetConfig, subsetID: string) {\r\n        if (!this.items.map[config.modelID]) this.items.generateGeometryIndexMap(config.modelID);\r\n        if (!this.subsets[subsetID]) this.initializeSubset(config, subsetID);\r\n        this.filterIndices(config, subsetID);\r\n        this.constructSubsetByMaterial(config, subsetID);\r\n        config.ids.forEach(id => this.subsets[subsetID].ids.add(id));\r\n        this.subsets[subsetID].mesh.geometry.setIndex(this.tempIndex);\r\n        this.tempIndex.length = 0;\r\n        const subset = this.subsets[subsetID].mesh;\r\n        if (config.applyBVH) this.BVH.applyThreeMeshBVH(subset.geometry);\r\n        if (config.scene) config.scene.add(subset);\r\n        return this.subsets[subsetID].mesh;\r\n    }\r\n\r\n    dispose() {\r\n        this.tempIndex = [];\r\n    }\r\n\r\n    private initializeSubset(config: SubsetConfig, subsetID: string) {\r\n        const model = this.state.models[config.modelID].mesh;\r\n        const subsetGeom = new BufferGeometry();\r\n        this.initializeSubsetAttributes(subsetGeom, model);\r\n        if (!config.material) this.initializeSubsetGroups(subsetGeom, model);\r\n        const mesh = new Mesh(subsetGeom, config.material || model.material) as Subset;\r\n        mesh.modelID = config.modelID;\r\n        const bvh = Boolean(config.applyBVH);\r\n        this.subsets[subsetID] = { ids: new Set<number>(), mesh, bvh };\r\n        model.add(mesh);\r\n    }\r\n\r\n    // The subset shares the same attributes as the original (no memory consumed)\r\n    private initializeSubsetAttributes(subsetGeom: BufferGeometry, model: Mesh) {\r\n        subsetGeom.setAttribute('position', model.geometry.attributes.position);\r\n        subsetGeom.setAttribute('normal', model.geometry.attributes.normal);\r\n        subsetGeom.setAttribute('expressID', model.geometry.attributes.expressID);\r\n        subsetGeom.setIndex([]);\r\n    }\r\n\r\n    // If the subset has original materials, initialize the groups for the subset\r\n    private initializeSubsetGroups(subsetGeom: BufferGeometry, model: Mesh) {\r\n        subsetGeom.groups = JSON.parse(JSON.stringify(model.geometry.groups));\r\n        this.resetGroups(subsetGeom);\r\n    }\r\n\r\n    // Remove previous indices or filter the given ones to avoid repeating items\r\n    private filterIndices(config: SubsetConfig, subsetID: string) {\r\n        const geometry = this.subsets[subsetID].mesh.geometry as IndexedGeometry;\r\n        if (config.removePrevious) {\r\n            geometry.setIndex([]);\r\n            this.resetGroups(geometry);\r\n            return;\r\n        }\r\n        const previousIndices = geometry.index.array;\r\n        const previousIDs = this.subsets[subsetID].ids;\r\n        config.ids = config.ids.filter(id => !previousIDs.has(id));\r\n        this.tempIndex = Array.from(previousIndices);\r\n    }\r\n\r\n    private constructSubsetByMaterial(config: SubsetConfig, subsetID: string) {\r\n        const model = this.state.models[config.modelID].mesh;\r\n        const newIndices = { count: 0 };\r\n        for (let i = 0; i < model.geometry.groups.length; i++) {\r\n            this.insertNewIndices(config, subsetID, i, newIndices);\r\n        }\r\n    }\r\n\r\n    // If this subset has original materials, insert indices in correct position and update groups\r\n    // Otherwise, just insert indices at any position\r\n    private insertNewIndices(config: SubsetConfig, subsetID: string, materialIndex: number, newIndices: any) {\r\n        const items = this.items.map[config.modelID];\r\n        const indicesOfOneMaterial = SubsetUtils.getAllIndicesOfGroup(config.modelID, config.ids, materialIndex, items) as number[];\r\n\r\n        if (!config.material) {\r\n            this.insertIndicesAtGroup(subsetID, indicesOfOneMaterial, materialIndex, newIndices);\r\n        } else {\r\n            indicesOfOneMaterial.forEach(index => this.tempIndex.push(index));\r\n        }\r\n    }\r\n\r\n    private insertIndicesAtGroup(subsetID: string, indicesByGroup: number[], index: number, newIndices: any) {\r\n        const currentGroup = this.getCurrentGroup(subsetID, index);\r\n        currentGroup.start += newIndices.count;\r\n        let newIndicesPosition = currentGroup.start + currentGroup.count;\r\n        newIndices.count += indicesByGroup.length;\r\n        if (indicesByGroup.length > 0) {\r\n            let position = newIndicesPosition;\r\n            const start = this.tempIndex.slice(0, position);\r\n            const end = this.tempIndex.slice(position);\r\n            this.tempIndex = Array.prototype.concat.apply([], [start, indicesByGroup, end]);\r\n            currentGroup.count += indicesByGroup.length;\r\n        }\r\n    }\r\n\r\n    private getCurrentGroup(subsetID: string, groupIndex: number) {\r\n        const geometry = this.subsets[subsetID].mesh.geometry as IndexedGeometry;\r\n        return geometry.groups[groupIndex];\r\n    }\r\n\r\n    private resetGroups(geometry: BufferGeometry) {\r\n        geometry.groups.forEach((group) => {\r\n            group.start = 0;\r\n            group.count = 0;\r\n        });\r\n    }\r\n}", "import { Material, Mesh, Object3D } from 'three';\r\nimport { SubsetConfig, IfcState } from '../../BaseDefinitions';\r\nimport { BvhManager } from '../BvhManager';\r\nimport { ItemsMap } from './ItemsMap';\r\nimport { SubsetCreator } from './SubsetCreator';\r\n\r\nexport interface Subset extends Mesh {\r\n    modelID: number;\r\n}\r\n\r\nexport type Subsets = {\r\n    [subsetID: string]: { ids: Set<number>, mesh: Subset, bvh: boolean };\r\n};\r\n\r\n/**\r\n * Contains the logic to get, create and delete geometric subsets of an IFC model. For example,\r\n * this can extract all the items in a specific IfcBuildingStorey and create a new Mesh.\r\n */\r\nexport class SubsetManager {\r\n    readonly items: ItemsMap;\r\n    private readonly BVH: BvhManager;\r\n    private state: IfcState;\r\n    private subsets: Subsets = {};\r\n    private subsetCreator: SubsetCreator;\r\n\r\n    constructor(state: IfcState, BVH: BvhManager) {\r\n        this.state = state;\r\n        this.items = new ItemsMap(state);\r\n        this.BVH = BVH;\r\n        this.subsetCreator = new SubsetCreator(state, this.items, this.subsets, this.BVH);\r\n    }\r\n\r\n    getAllSubsets(){\r\n        return this.subsets\r\n    }\r\n\r\n    getSubset(modelID: number, material?: Material, customId?: string) {\r\n        const subsetID = this.getSubsetID(modelID, material, customId);\r\n        return this.subsets[subsetID].mesh;\r\n    }\r\n\r\n    removeSubset(modelID: number, material?: Material, customID?: string) {\r\n        const subsetID = this.getSubsetID(modelID, material, customID);\r\n        const subset = this.subsets[subsetID];\r\n        if (!subset) return;\r\n        if (subset.mesh.parent) subset.mesh.removeFromParent();\r\n        subset.mesh.geometry.attributes = {};\r\n        subset.mesh.geometry.index = null;\r\n        subset.mesh.geometry.dispose();\r\n        // @ts-ignore\r\n        subset.mesh.geometry = null;\r\n        delete this.subsets[subsetID];\r\n    }\r\n\r\n    createSubset(config: SubsetConfig) {\r\n        const subsetID = this.getSubsetID(config.modelID, config.material, config.customID);\r\n        return this.subsetCreator.createSubset(config, subsetID);\r\n    }\r\n\r\n    removeFromSubset(modelID: number, ids: number[], customID?: string, material?: Material) {\r\n        const subsetID = this.getSubsetID(modelID, material, customID);\r\n        if (!this.subsets[subsetID]) return;\r\n\r\n        const previousIDs = this.subsets[subsetID].ids;\r\n        ids.forEach((id) => {\r\n            if(previousIDs.has(id)) previousIDs.delete(id);\r\n        })\r\n\r\n        return this.createSubset({\r\n            modelID,\r\n            removePrevious: true,\r\n            material,\r\n            customID,\r\n            applyBVH: this.subsets[subsetID].bvh,\r\n            ids: Array.from(previousIDs),\r\n            scene: this.subsets[subsetID].mesh.parent as Object3D\r\n        });\r\n    }\r\n\r\n    clearSubset(modelID: number, customID?: string, material?: Material) {\r\n        const subsetID = this.getSubsetID(modelID, material, customID);\r\n        if (!this.subsets[subsetID]) return;\r\n        this.subsets[subsetID].ids.clear();\r\n        const subset = this.getSubset(modelID, material, customID);\r\n        subset.geometry.setIndex([]);\r\n    }\r\n\r\n    // Use this only for destroying the current IFCLoader instance\r\n    dispose() {\r\n        this.items.dispose();\r\n        this.subsetCreator.dispose();\r\n\r\n        Object.values(this.subsets).forEach(subset => {\r\n            (subset.ids as any) = null;\r\n            subset.mesh.removeFromParent();\r\n            const mats = subset.mesh.material;\r\n            if(Array.isArray(mats)) mats.forEach(mat => mat.dispose());\r\n            else mats.dispose();\r\n            subset.mesh.geometry.index = null;\r\n            subset.mesh.geometry.dispose();\r\n            const geom = subset.mesh.geometry as any;\r\n            if(geom.disposeBoundsTree) geom.disposeBoundsTree();\r\n            (subset.mesh as any) = null;\r\n        });\r\n        (this.subsets as any) = null;\r\n    }\r\n\r\n    private getSubsetID(modelID: number, material?: Material, customID = 'DEFAULT') {\r\n        const baseID = modelID;\r\n        const materialID = material ? material.uuid : 'DEFAULT';\r\n        return `${baseID} - ${materialID} - ${customID}`;\r\n    }\r\n}\r\n", "import { BufferAttribute, BufferGeometry, Material, Matrix4, Mesh, Object3D } from 'three';\r\n// TODO: Remove ts ignore comments when @types/three gets updated\r\n// @ts-ignore\r\nimport { mergeBufferGeometries } from 'three/examples/jsm/utils/BufferGeometryUtils';\r\nimport {\r\n    FlatMesh,\r\n    IfcGeometry,\r\n    IFCRELAGGREGATES, IFCRELASSOCIATESMATERIAL,\r\n    IFCRELCONTAINEDINSPATIALSTRUCTURE,\r\n    IFCRELDEFINESBYPROPERTIES,\r\n    IFCRELDEFINESBYTYPE, LoaderError, LoaderSettings, RawLineData, Vector\r\n} from 'web-ifc';\r\nimport {ParserProgress} from \"./components/IFCParser\";\r\n\r\nexport const IdAttrName = 'expressID';\r\n\r\nexport type IdAttributeByMaterial = { [id: number]: number };\r\nexport type IdAttributesByMaterials = { [materialID: string]: IdAttributeByMaterial };\r\n\r\n//TODO: Rename \"scene\" to \"parent\" in the next major release\r\nexport interface BaseSubsetConfig {\r\n    scene?: Object3D;\r\n    ids: number[];\r\n    removePrevious: boolean;\r\n    material?: Material;\r\n    customID?: string;\r\n    applyBVH?: boolean;\r\n}\r\n\r\nexport interface SubsetConfig extends BaseSubsetConfig {\r\n    modelID: number;\r\n}\r\n\r\nexport const DEFAULT = 'default';\r\n\r\nexport type MapFaceindexID = { [key: number]: number };\r\n\r\nexport interface TypesMap {\r\n    [key: number]: number;\r\n}\r\n\r\n\r\nexport interface IfcModel {\r\n    modelID: number;\r\n    mesh: IfcMesh;\r\n    types: TypesMap;\r\n    jsonData: { [id: number]: JSONObject };\r\n}\r\n\r\nexport interface JSONObject {\r\n    expressID: number;\r\n    type: string;\r\n    [key: string]: any;\r\n}\r\n\r\nexport interface Worker {\r\n    active: boolean;\r\n    path: string;\r\n}\r\n\r\nexport interface IfcState {\r\n    models: { [modelID: number]: IfcModel };\r\n    api: WebIfcAPI;\r\n    useJSON: boolean;\r\n    worker: Worker;\r\n    webIfcSettings?: LoaderSettings;\r\n    onProgress?: (event: ParserProgress) => void;\r\n    coordinationMatrix?: Matrix4,\r\n    wasmPath?: string;\r\n}\r\n\r\nexport interface IfcMesh extends Mesh {\r\n    modelID: number;\r\n}\r\n\r\nexport interface Node {\r\n    expressID: number;\r\n    type: string;\r\n    children: Node[];\r\n}\r\n\r\nexport interface pName {\r\n    name: number;\r\n    relating: string;\r\n    related: string;\r\n    key: string;\r\n}\r\n\r\nexport const PropsNames = {\r\n    aggregates: {\r\n        name: IFCRELAGGREGATES,\r\n        relating: 'RelatingObject',\r\n        related: 'RelatedObjects',\r\n        key: 'children'\r\n    },\r\n    spatial: {\r\n        name: IFCRELCONTAINEDINSPATIALSTRUCTURE,\r\n        relating: 'RelatingStructure',\r\n        related: 'RelatedElements',\r\n        key: 'children'\r\n    },\r\n    psets: {\r\n        name: IFCRELDEFINESBYPROPERTIES,\r\n        relating: 'RelatingPropertyDefinition',\r\n        related: 'RelatedObjects',\r\n        key: 'hasPsets'\r\n    },\r\n    materials: {\r\n        name: IFCRELASSOCIATESMATERIAL,\r\n        relating: 'RelatingMaterial',\r\n        related: 'RelatedObjects',\r\n        key: 'hasMaterial'\r\n    },\r\n    type: {\r\n        name: IFCRELDEFINESBYTYPE,\r\n        relating: 'RelatingType',\r\n        related: 'RelatedObjects',\r\n        key: 'hasType'\r\n    }\r\n};\r\n\r\nexport interface WebIfcAPI {\r\n\r\n    wasmModule: any;\r\n\r\n    Init(): void | Promise<void>;\r\n\r\n    // To close the web worker\r\n    Close?: () => void;\r\n\r\n    /**\r\n     * Opens a model and returns a modelID number\r\n     * @data Buffer containing IFC data (bytes)\r\n     * @data Settings settings for loading the model\r\n     */\r\n    OpenModel(data: string | Uint8Array, settings?: LoaderSettings): number | Promise<number>;\r\n\r\n    /**\r\n     * Creates a new model and returns a modelID number\r\n     * @data Settings settings for generating data the model\r\n     */\r\n    CreateModel(settings?: LoaderSettings): number | Promise<number>;\r\n\r\n    ExportFileAsIFC(modelID: number): Uint8Array | Promise<Uint8Array>;\r\n\r\n    /**\r\n     * Opens a model and returns a modelID number\r\n     * @modelID Model handle retrieved by OpenModel, model must not be closed\r\n     * @data Buffer containing IFC data (bytes)\r\n     */\r\n    GetGeometry(modelID: number, geometryExpressID: number): IfcGeometry | Promise<IfcGeometry>;\r\n\r\n    GetLine(modelID: number, expressID: number, flatten?: boolean):  any | Promise<any>;\r\n\r\n    GetAndClearErrors(modelID: number): Vector<LoaderError> | Promise<Vector<LoaderError>>;\r\n\r\n    WriteLine(modelID: number, lineObject: any): void | Promise<void>;\r\n\r\n    FlattenLine(modelID: number, line: any): void | Promise<void>;\r\n\r\n    GetRawLineData(modelID: number, expressID: number): RawLineData | Promise<RawLineData>;\r\n\r\n    WriteRawLineData(modelID: number, data: RawLineData):  any | Promise<any>;\r\n\r\n    GetLineIDsWithType(modelID: number, type: number): Vector<number> | Promise<Vector<number>>;\r\n\r\n    GetAllLines(modelID: Number): Vector<number> | Promise<Vector<number>>;\r\n\r\n    SetGeometryTransformation(modelID: number, transformationMatrix: Array<number>): void | Promise<void>;\r\n\r\n    GetCoordinationMatrix(modelID: number): Array<number> | Promise<Array<number>>;\r\n\r\n    GetVertexArray(ptr: number, size: number): Float32Array | Promise<Float32Array>;\r\n\r\n    GetIndexArray(ptr: number, size: number): Uint32Array | Promise<Uint32Array>;\r\n\r\n    getSubArray(heap: any, startPtr: any, sizeBytes: any): any | Promise<any>;\r\n\r\n    /**\r\n     * Closes a model and frees all related memory\r\n     * @modelID Model handle retrieved by OpenModel, model must not be closed\r\n     */\r\n    CloseModel(modelID: number): void | Promise<void>;\r\n\r\n    StreamAllMeshes(modelID: number, meshCallback: (mesh: FlatMesh) => void): void | Promise<void>;\r\n\r\n    StreamAllMeshesWithTypes(modelID: number, types: Array<number>, meshCallback: (mesh: FlatMesh) => void): void | Promise<void>;\r\n\r\n    /**\r\n     * Checks if a specific model ID is open or closed\r\n     * @modelID Model handle retrieved by OpenModel\r\n     */\r\n    IsModelOpen(modelID: number): boolean | Promise<boolean>;\r\n\r\n    /**\r\n     * Load all geometry in a model\r\n     * @modelID Model handle retrieved by OpenModel\r\n     */\r\n    LoadAllGeometry(modelID: number): Vector<FlatMesh> | Promise<Vector<FlatMesh>>;\r\n\r\n    /**\r\n     * Load geometry for a single element\r\n     * @modelID Model handle retrieved by OpenModel\r\n     */\r\n    GetFlatMesh(modelID: number, expressID: number): FlatMesh | Promise<FlatMesh>;\r\n\r\n    SetWasmPath(path: string): void | Promise<void>;\r\n}\r\n", "import { IfcState, pName, PropsNames, Node } from '../../BaseDefinitions';\r\n\r\nexport class BasePropertyManager {\r\n\r\n    constructor(protected state: IfcState) {\r\n    }\r\n\r\n    async getPropertySets(modelID: number, elementID: number, recursive = false) {\r\n        return await this.getProperty(modelID, elementID, recursive, PropsNames.psets);\r\n    }\r\n\r\n    async getTypeProperties(modelID: number, elementID: number, recursive = false) {\r\n        return await this.getProperty(modelID, elementID, recursive, PropsNames.type);\r\n    }\r\n\r\n    async getMaterialsProperties(modelID: number, elementID: number, recursive = false) {\r\n        return await this.getProperty(modelID, elementID, recursive, PropsNames.materials);\r\n    }\r\n\r\n    protected async getSpatialNode(modelID: number, node: Node, treeChunks: any, includeProperties?: boolean) {\r\n        await this.getChildren(modelID, node, treeChunks, PropsNames.aggregates, includeProperties);\r\n        await this.getChildren(modelID, node, treeChunks, PropsNames.spatial, includeProperties);\r\n    }\r\n\r\n    protected async getChildren(modelID: number, node: Node, treeChunks: any, propNames: pName, includeProperties?: boolean) {\r\n        const children = treeChunks[node.expressID];\r\n        if (children == undefined) return;\r\n        const prop = propNames.key as keyof Node;\r\n        const nodes: any[] = [];\r\n        for(let i = 0; i < children.length; i++){\r\n            const child = children[i];\r\n            let node = this.newNode(modelID, child);\r\n            if (includeProperties) {\r\n                const properties = await this.getItemProperties(modelID, node.expressID) as any;\r\n                node = { ...properties, ...node };\r\n            }\r\n            await this.getSpatialNode(modelID, node, treeChunks, includeProperties);\r\n            nodes.push(node);\r\n        }\r\n        (node[prop] as Node[]) = nodes;\r\n    }\r\n\r\n    protected newNode(modelID: number, id: number) {\r\n        const typeName = this.getNodeType(modelID, id);\r\n        return {\r\n            expressID: id,\r\n            type: typeName,\r\n            children: []\r\n        };\r\n    }\r\n\r\n    protected async getSpatialTreeChunks(modelID: number) {\r\n        const treeChunks: any = {};\r\n        await this.getChunks(modelID, treeChunks, PropsNames.aggregates);\r\n        await this.getChunks(modelID, treeChunks, PropsNames.spatial);\r\n        return treeChunks;\r\n    }\r\n\r\n    protected saveChunk(chunks: any, propNames: pName, rel: any) {\r\n        const relating = rel[propNames.relating].value;\r\n        const related = rel[propNames.related].map((r: any) => r.value);\r\n        if (chunks[relating] == undefined) {\r\n            chunks[relating] = related;\r\n        } else {\r\n            chunks[relating] = chunks[relating].concat(related);\r\n        }\r\n    }\r\n\r\n    protected getRelated(rel: any, propNames: pName, IDs: number[]) {\r\n        const element = rel[propNames.relating];\r\n        if(!element) {\r\n            return console.warn(`The object with ID ${rel.expressID} has a broken reference.`);\r\n        }\r\n        if (!Array.isArray(element)) IDs.push(element.value);\r\n        else element.forEach((ele) => IDs.push(ele.value));\r\n    }\r\n\r\n    protected static isRelated(id: number, rel: any, propNames: pName) {\r\n        const relatedItems = rel[propNames.related];\r\n        if (Array.isArray(relatedItems)) {\r\n            const values = relatedItems.map((item) => item.value);\r\n            return values.includes(id);\r\n        }\r\n        return relatedItems.value === id;\r\n    }\r\n\r\n    protected static newIfcProject(id: number) {\r\n        return {\r\n            expressID: id,\r\n            type: 'IFCPROJECT',\r\n            children: []\r\n        };\r\n    }\r\n\r\n    async getProperty(modelID: number, elementID: number, recursive = false, propName: pName): Promise<any> {\r\n    }\r\n\r\n    protected async getChunks(modelID: number, chunks: any, propNames: pName): Promise<void> {\r\n    }\r\n\r\n    protected async getItemProperties(modelID: number, expressID: number, recursive = false): Promise<any> {\r\n    }\r\n\r\n    protected getNodeType(modelID: number, id: number): any {\r\n    }\r\n}", "export let IfcElements: {[key: number]: string} = {\r\n  103090709: 'IFCPROJECT',\r\n  4097777520: 'IFCSITE',\r\n  4031249490: 'IFCBUILDING',\r\n  3124254112: 'IFCBUILDINGSTOREY',\r\n  3856911033: 'IFCSPACE',\r\n  1674181508: 'IFCANNOTATION',\r\n  25142252: 'IFCCONTROLLER',\r\n  32344328: 'IFCBOILER',\r\n  76236018: 'IFCLAMP',\r\n  90941305: 'IFCPUMP',\r\n  177149247: 'IFCAIRTERMINALBOX',\r\n  182646315: 'IFCFLOWINSTRUMENT',\r\n  263784265: 'IFCFURNISHINGELEMENT',\r\n  264262732: 'IFCELECTRICGENERATOR',\r\n  277319702: 'IFCAUDIOVISUALAPPLIANCE',\r\n  310824031: 'IFCPIPEFITTING',\r\n  331165859: 'IFCSTAIR',\r\n  342316401: 'IFCDUCTFITTING',\r\n  377706215: 'IFCMECHANICALFASTENER',\r\n  395920057: 'IFCDOOR',\r\n  402227799: 'IFCELECTRICMOTOR',\r\n  413509423: 'IFCSYSTEMFURNITUREELEMENT',\r\n  484807127: 'IFCEVAPORATOR',\r\n  486154966: 'IFCWINDOWSTANDARDCASE',\r\n  629592764: 'IFCLIGHTFIXTURE',\r\n  630975310: 'IFCUNITARYCONTROLELEMENT',\r\n  635142910: 'IFCCABLECARRIERFITTING',\r\n  639361253: 'IFCCOIL',\r\n  647756555: 'IFCFASTENER',\r\n  707683696: 'IFCFLOWSTORAGEDEVICE',\r\n  738039164: 'IFCPROTECTIVEDEVICE',\r\n  753842376: 'IFCBEAM',\r\n  812556717: 'IFCTANK',\r\n  819412036: 'IFCFILTER',\r\n  843113511: 'IFCCOLUMN',\r\n  862014818: 'IFCELECTRICDISTRIBUTIONBOARD',\r\n  900683007: 'IFCFOOTING',\r\n  905975707: 'IFCCOLUMNSTANDARDCASE',\r\n  926996030: 'IFCVOIDINGFEATURE',\r\n  979691226: 'IFCREINFORCINGBAR',\r\n  987401354: 'IFCFLOWSEGMENT',\r\n  1003880860: 'IFCELECTRICTIMECONTROL',\r\n  1051757585: 'IFCCABLEFITTING',\r\n  1052013943: 'IFCDISTRIBUTIONCHAMBERELEMENT',\r\n  1062813311: 'IFCDISTRIBUTIONCONTROLELEMENT',\r\n  1073191201: 'IFCMEMBER',\r\n  1095909175: 'IFCBUILDINGELEMENTPROXY',\r\n  1156407060: 'IFCPLATESTANDARDCASE',\r\n  1162798199: 'IFCSWITCHINGDEVICE',\r\n  1329646415: 'IFCSHADINGDEVICE',\r\n  1335981549: 'IFCDISCRETEACCESSORY',\r\n  1360408905: 'IFCDUCTSILENCER',\r\n  1404847402: 'IFCSTACKTERMINAL',\r\n  1426591983: 'IFCFIRESUPPRESSIONTERMINAL',\r\n  1437502449: 'IFCMEDICALDEVICE',\r\n  1509553395: 'IFCFURNITURE',\r\n  1529196076: 'IFCSLAB',\r\n  1620046519: 'IFCTRANSPORTELEMENT',\r\n  1634111441: 'IFCAIRTERMINAL',\r\n  1658829314: 'IFCENERGYCONVERSIONDEVICE',\r\n  1677625105: 'IFCCIVILELEMENT',\r\n  1687234759: 'IFCPILE',\r\n  1904799276: 'IFCELECTRICAPPLIANCE',\r\n  1911478936: 'IFCMEMBERSTANDARDCASE',\r\n  1945004755: 'IFCDISTRIBUTIONELEMENT',\r\n  1973544240: 'IFCCOVERING',\r\n  1999602285: 'IFCSPACEHEATER',\r\n  2016517767: 'IFCROOF',\r\n  2056796094: 'IFCAIRTOAIRHEATRECOVERY',\r\n  2058353004: 'IFCFLOWCONTROLLER',\r\n  2068733104: 'IFCHUMIDIFIER',\r\n  2176052936: 'IFCJUNCTIONBOX',\r\n  2188021234: 'IFCFLOWMETER',\r\n  2223149337: 'IFCFLOWTERMINAL',\r\n  2262370178: 'IFCRAILING',\r\n  2272882330: 'IFCCONDENSER',\r\n  2295281155: 'IFCPROTECTIVEDEVICETRIPPINGUNIT',\r\n  2320036040: 'IFCREINFORCINGMESH',\r\n  2347447852: 'IFCTENDONANCHOR',\r\n  2391383451: 'IFCVIBRATIONISOLATOR',\r\n  2391406946: 'IFCWALL',\r\n  2474470126: 'IFCMOTORCONNECTION',\r\n  2769231204: 'IFCVIRTUALELEMENT',\r\n  2814081492: 'IFCENGINE',\r\n  2906023776: 'IFCBEAMSTANDARDCASE',\r\n  2938176219: 'IFCBURNER',\r\n  2979338954: 'IFCBUILDINGELEMENTPART',\r\n  3024970846: 'IFCRAMP',\r\n  3026737570: 'IFCTUBEBUNDLE',\r\n  3027962421: 'IFCSLABSTANDARDCASE',\r\n  3040386961: 'IFCDISTRIBUTIONFLOWELEMENT',\r\n  3053780830: 'IFCSANITARYTERMINAL',\r\n  3079942009: 'IFCOPENINGSTANDARDCASE',\r\n  3087945054: 'IFCALARM',\r\n  3101698114: 'IFCSURFACEFEATURE',\r\n  3127900445: 'IFCSLABELEMENTEDCASE',\r\n  3132237377: 'IFCFLOWMOVINGDEVICE',\r\n  3171933400: 'IFCPLATE',\r\n  3221913625: 'IFCCOMMUNICATIONSAPPLIANCE',\r\n  3242481149: 'IFCDOORSTANDARDCASE',\r\n  3283111854: 'IFCRAMPFLIGHT',\r\n  3296154744: 'IFCCHIMNEY',\r\n  3304561284: 'IFCWINDOW',\r\n  3310460725: 'IFCELECTRICFLOWSTORAGEDEVICE',\r\n  3319311131: 'IFCHEATEXCHANGER',\r\n  3415622556: 'IFCFAN',\r\n  3420628829: 'IFCSOLARDEVICE',\r\n  3493046030: 'IFCGEOGRAPHICELEMENT',\r\n  3495092785: 'IFCCURTAINWALL',\r\n  3508470533: 'IFCFLOWTREATMENTDEVICE',\r\n  3512223829: 'IFCWALLSTANDARDCASE',\r\n  3518393246: 'IFCDUCTSEGMENT',\r\n  3571504051: 'IFCCOMPRESSOR',\r\n  3588315303: 'IFCOPENINGELEMENT',\r\n  3612865200: 'IFCPIPESEGMENT',\r\n  3640358203: 'IFCCOOLINGTOWER',\r\n  3651124850: 'IFCPROJECTIONELEMENT',\r\n  3694346114: 'IFCOUTLET',\r\n  3747195512: 'IFCEVAPORATIVECOOLER',\r\n  3758799889: 'IFCCABLECARRIERSEGMENT',\r\n  3824725483: 'IFCTENDON',\r\n  3825984169: 'IFCTRANSFORMER',\r\n  3902619387: 'IFCCHILLER',\r\n  4074379575: 'IFCDAMPER',\r\n  4086658281: 'IFCSENSOR',\r\n  4123344466: 'IFCELEMENTASSEMBLY',\r\n  4136498852: 'IFCCOOLEDBEAM',\r\n  4156078855: 'IFCWALLELEMENTEDCASE',\r\n  4175244083: 'IFCINTERCEPTOR',\r\n  4207607924: 'IFCVALVE',\r\n  4217484030: 'IFCCABLESEGMENT',\r\n  4237592921: 'IFCWASTETERMINAL',\r\n  4252922144: 'IFCSTAIRFLIGHT',\r\n  4278956645: 'IFCFLOWFITTING',\r\n  4288193352: 'IFCACTUATOR',\r\n  4292641817: 'IFCUNITARYEQUIPMENT',\r\n  3009204131: 'IFCGRID'\r\n};", "import { BasePropertyManager } from './BasePropertyManager';\r\nimport { IFCPROJECT } from 'web-ifc';\r\nimport { pName } from '../../BaseDefinitions';\r\nimport { PropertyAPI } from './BaseDefinitions';\r\nimport { IfcElements } from '../IFCElementsMap';\r\n\r\nexport class WebIfcPropertyManager extends BasePropertyManager  implements PropertyAPI {\r\n    async getItemProperties(modelID: number, id: number, recursive = false) {\r\n        return this.state.api.GetLine(modelID, id, recursive);\r\n    }\r\n\r\n    async getSpatialStructure(modelID: number, includeProperties?: boolean) {\r\n        const chunks = await this.getSpatialTreeChunks(modelID);\r\n        const allLines = await this.state.api.GetLineIDsWithType(modelID, IFCPROJECT);\r\n        const projectID = allLines.get(0);\r\n        const project = WebIfcPropertyManager.newIfcProject(projectID);\r\n        await this.getSpatialNode(modelID, project, chunks, includeProperties);\r\n        return project;\r\n    }\r\n\r\n    async getAllItemsOfType(modelID: number, type: number, verbose: boolean) {\r\n        let items: number[] = [];\r\n        const lines = await this.state.api.GetLineIDsWithType(modelID, type);\r\n        for (let i = 0; i < lines.size(); i++) items.push(lines.get(i));\r\n        if (!verbose) return items;\r\n        const result: any[] = [];\r\n        for (let i = 0; i < items.length; i++) {\r\n            result.push(await this.state.api.GetLine(modelID, items[i]));\r\n        }\r\n        return result;\r\n    }\r\n\r\n    override async getProperty(modelID: number, elementID: number, recursive = false, propName: pName) {\r\n        const propSetIds = await this.getAllRelatedItemsOfType(modelID, elementID, propName);\r\n        const result: any[] = [];\r\n        for (let i = 0; i < propSetIds.length; i++) {\r\n            result.push(await this.state.api.GetLine(modelID, propSetIds[i], recursive));\r\n        }\r\n        return result;\r\n    }\r\n\r\n    protected override getNodeType(modelID: number, id: number) {\r\n        const typeID = this.state.models[modelID].types[id];\r\n        return IfcElements[typeID];\r\n    }\r\n\r\n    protected override async getChunks(modelID: number, chunks: any, propNames: pName) {\r\n        const relation = await this.state.api.GetLineIDsWithType(modelID, propNames.name);\r\n        for (let i = 0; i < relation.size(); i++) {\r\n            const rel = await this.state.api.GetLine(modelID, relation.get(i), false);\r\n            this.saveChunk(chunks, propNames, rel);\r\n        }\r\n    }\r\n\r\n    private async getAllRelatedItemsOfType(modelID: number, id: number, propNames: pName) {\r\n        const lines = await this.state.api.GetLineIDsWithType(modelID, propNames.name);\r\n        const IDs: number[] = [];\r\n        for (let i = 0; i < lines.size(); i++) {\r\n            const rel = await this.state.api.GetLine(modelID, lines.get(i));\r\n            const isRelated = BasePropertyManager.isRelated(id, rel, propNames);\r\n            if (isRelated) this.getRelated(rel, propNames, IDs);\r\n        }\r\n        return IDs;\r\n    }\r\n}", "export let IfcTypesMap:  {[key: number]: string} = {\r\n    3821786052: \"IFCACTIONREQUEST\",\r\n    2296667514: \"IFCACTOR\",\r\n    3630933823: \"IFCACTORROLE\",\r\n    4288193352: \"IFCACTUATOR\",\r\n    2874132201: \"IFCACTUATORTYPE\",\r\n    618182010: \"IFCADDRESS\",\r\n    1635779807: \"IFCADVANCEDBREP\",\r\n    2603310189: \"IFCADVANCEDBREPWITHVOIDS\",\r\n    3406155212: \"IFCADVANCEDFACE\",\r\n    1634111441: \"IFCAIRTERMINAL\",\r\n    177149247: \"IFCAIRTERMINALBOX\",\r\n    1411407467: \"IFCAIRTERMINALBOXTYPE\",\r\n    3352864051: \"IFCAIRTERMINALTYPE\",\r\n    2056796094: \"IFCAIRTOAIRHEATRECOVERY\",\r\n    1871374353: \"IFCAIRTOAIRHEATRECOVERYTYPE\",\r\n    3087945054: \"IFCALARM\",\r\n    3001207471: \"IFCALARMTYPE\",\r\n    325726236: \"IFCALIGNMENT\",\r\n    749761778: \"IFCALIGNMENT2DHORIZONTAL\",\r\n    3199563722: \"IFCALIGNMENT2DHORIZONTALSEGMENT\",\r\n    2483840362: \"IFCALIGNMENT2DSEGMENT\",\r\n    3379348081: \"IFCALIGNMENT2DVERSEGCIRCULARARC\",\r\n    3239324667: \"IFCALIGNMENT2DVERSEGLINE\",\r\n    4263986512: \"IFCALIGNMENT2DVERSEGPARABOLICARC\",\r\n    53199957: \"IFCALIGNMENT2DVERTICAL\",\r\n    2029264950: \"IFCALIGNMENT2DVERTICALSEGMENT\",\r\n    3512275521: \"IFCALIGNMENTCURVE\",\r\n    1674181508: \"IFCANNOTATION\",\r\n    669184980: \"IFCANNOTATIONFILLAREA\",\r\n    639542469: \"IFCAPPLICATION\",\r\n    411424972: \"IFCAPPLIEDVALUE\",\r\n    130549933: \"IFCAPPROVAL\",\r\n    3869604511: \"IFCAPPROVALRELATIONSHIP\",\r\n    3798115385: \"IFCARBITRARYCLOSEDPROFILEDEF\",\r\n    1310608509: \"IFCARBITRARYOPENPROFILEDEF\",\r\n    2705031697: \"IFCARBITRARYPROFILEDEFWITHVOIDS\",\r\n    3460190687: \"IFCASSET\",\r\n    3207858831: \"IFCASYMMETRICISHAPEPROFILEDEF\",\r\n    277319702: \"IFCAUDIOVISUALAPPLIANCE\",\r\n    1532957894: \"IFCAUDIOVISUALAPPLIANCETYPE\",\r\n    4261334040: \"IFCAXIS1PLACEMENT\",\r\n    3125803723: \"IFCAXIS2PLACEMENT2D\",\r\n    2740243338: \"IFCAXIS2PLACEMENT3D\",\r\n    1967976161: \"IFCBSPLINECURVE\",\r\n    2461110595: \"IFCBSPLINECURVEWITHKNOTS\",\r\n    2887950389: \"IFCBSPLINESURFACE\",\r\n    167062518: \"IFCBSPLINESURFACEWITHKNOTS\",\r\n    753842376: \"IFCBEAM\",\r\n    2906023776: \"IFCBEAMSTANDARDCASE\",\r\n    819618141: \"IFCBEAMTYPE\",\r\n    4196446775: \"IFCBEARING\",\r\n    3649138523: \"IFCBEARINGTYPE\",\r\n    616511568: \"IFCBLOBTEXTURE\",\r\n    1334484129: \"IFCBLOCK\",\r\n    32344328: \"IFCBOILER\",\r\n    231477066: \"IFCBOILERTYPE\",\r\n    3649129432: \"IFCBOOLEANCLIPPINGRESULT\",\r\n    2736907675: \"IFCBOOLEANRESULT\",\r\n    4037036970: \"IFCBOUNDARYCONDITION\",\r\n    1136057603: \"IFCBOUNDARYCURVE\",\r\n    1560379544: \"IFCBOUNDARYEDGECONDITION\",\r\n    3367102660: \"IFCBOUNDARYFACECONDITION\",\r\n    1387855156: \"IFCBOUNDARYNODECONDITION\",\r\n    2069777674: \"IFCBOUNDARYNODECONDITIONWARPING\",\r\n    1260505505: \"IFCBOUNDEDCURVE\",\r\n    4182860854: \"IFCBOUNDEDSURFACE\",\r\n    2581212453: \"IFCBOUNDINGBOX\",\r\n    2713105998: \"IFCBOXEDHALFSPACE\",\r\n    644574406: \"IFCBRIDGE\",\r\n    963979645: \"IFCBRIDGEPART\",\r\n    4031249490: \"IFCBUILDING\",\r\n    3299480353: \"IFCBUILDINGELEMENT\",\r\n    2979338954: \"IFCBUILDINGELEMENTPART\",\r\n    39481116: \"IFCBUILDINGELEMENTPARTTYPE\",\r\n    1095909175: \"IFCBUILDINGELEMENTPROXY\",\r\n    1909888760: \"IFCBUILDINGELEMENTPROXYTYPE\",\r\n    1950629157: \"IFCBUILDINGELEMENTTYPE\",\r\n    3124254112: \"IFCBUILDINGSTOREY\",\r\n    1177604601: \"IFCBUILDINGSYSTEM\",\r\n    2938176219: \"IFCBURNER\",\r\n    2188180465: \"IFCBURNERTYPE\",\r\n    2898889636: \"IFCCSHAPEPROFILEDEF\",\r\n    635142910: \"IFCCABLECARRIERFITTING\",\r\n    395041908: \"IFCCABLECARRIERFITTINGTYPE\",\r\n    3758799889: \"IFCCABLECARRIERSEGMENT\",\r\n    3293546465: \"IFCCABLECARRIERSEGMENTTYPE\",\r\n    1051757585: \"IFCCABLEFITTING\",\r\n    2674252688: \"IFCCABLEFITTINGTYPE\",\r\n    4217484030: \"IFCCABLESEGMENT\",\r\n    1285652485: \"IFCCABLESEGMENTTYPE\",\r\n    3999819293: \"IFCCAISSONFOUNDATION\",\r\n    3203706013: \"IFCCAISSONFOUNDATIONTYPE\",\r\n    1123145078: \"IFCCARTESIANPOINT\",\r\n    574549367: \"IFCCARTESIANPOINTLIST\",\r\n    1675464909: \"IFCCARTESIANPOINTLIST2D\",\r\n    2059837836: \"IFCCARTESIANPOINTLIST3D\",\r\n    59481748: \"IFCCARTESIANTRANSFORMATIONOPERATOR\",\r\n    3749851601: \"IFCCARTESIANTRANSFORMATIONOPERATOR2D\",\r\n    3486308946: \"IFCCARTESIANTRANSFORMATIONOPERATOR2DNONUNIFORM\",\r\n    3331915920: \"IFCCARTESIANTRANSFORMATIONOPERATOR3D\",\r\n    1416205885: \"IFCCARTESIANTRANSFORMATIONOPERATOR3DNONUNIFORM\",\r\n    3150382593: \"IFCCENTERLINEPROFILEDEF\",\r\n    3902619387: \"IFCCHILLER\",\r\n    2951183804: \"IFCCHILLERTYPE\",\r\n    3296154744: \"IFCCHIMNEY\",\r\n    2197970202: \"IFCCHIMNEYTYPE\",\r\n    2611217952: \"IFCCIRCLE\",\r\n    2937912522: \"IFCCIRCLEHOLLOWPROFILEDEF\",\r\n    1383045692: \"IFCCIRCLEPROFILEDEF\",\r\n    1062206242: \"IFCCIRCULARARCSEGMENT2D\",\r\n    1677625105: \"IFCCIVILELEMENT\",\r\n    3893394355: \"IFCCIVILELEMENTTYPE\",\r\n    747523909: \"IFCCLASSIFICATION\",\r\n    647927063: \"IFCCLASSIFICATIONREFERENCE\",\r\n    2205249479: \"IFCCLOSEDSHELL\",\r\n    639361253: \"IFCCOIL\",\r\n    2301859152: \"IFCCOILTYPE\",\r\n    776857604: \"IFCCOLOURRGB\",\r\n    3285139300: \"IFCCOLOURRGBLIST\",\r\n    3264961684: \"IFCCOLOURSPECIFICATION\",\r\n    843113511: \"IFCCOLUMN\",\r\n    905975707: \"IFCCOLUMNSTANDARDCASE\",\r\n    300633059: \"IFCCOLUMNTYPE\",\r\n    3221913625: \"IFCCOMMUNICATIONSAPPLIANCE\",\r\n    400855858: \"IFCCOMMUNICATIONSAPPLIANCETYPE\",\r\n    2542286263: \"IFCCOMPLEXPROPERTY\",\r\n    3875453745: \"IFCCOMPLEXPROPERTYTEMPLATE\",\r\n    3732776249: \"IFCCOMPOSITECURVE\",\r\n    15328376: \"IFCCOMPOSITECURVEONSURFACE\",\r\n    2485617015: \"IFCCOMPOSITECURVESEGMENT\",\r\n    1485152156: \"IFCCOMPOSITEPROFILEDEF\",\r\n    3571504051: \"IFCCOMPRESSOR\",\r\n    3850581409: \"IFCCOMPRESSORTYPE\",\r\n    2272882330: \"IFCCONDENSER\",\r\n    2816379211: \"IFCCONDENSERTYPE\",\r\n    2510884976: \"IFCCONIC\",\r\n    370225590: \"IFCCONNECTEDFACESET\",\r\n    1981873012: \"IFCCONNECTIONCURVEGEOMETRY\",\r\n    2859738748: \"IFCCONNECTIONGEOMETRY\",\r\n    45288368: \"IFCCONNECTIONPOINTECCENTRICITY\",\r\n    2614616156: \"IFCCONNECTIONPOINTGEOMETRY\",\r\n    2732653382: \"IFCCONNECTIONSURFACEGEOMETRY\",\r\n    775493141: \"IFCCONNECTIONVOLUMEGEOMETRY\",\r\n    1959218052: \"IFCCONSTRAINT\",\r\n    3898045240: \"IFCCONSTRUCTIONEQUIPMENTRESOURCE\",\r\n    2185764099: \"IFCCONSTRUCTIONEQUIPMENTRESOURCETYPE\",\r\n    1060000209: \"IFCCONSTRUCTIONMATERIALRESOURCE\",\r\n    4105962743: \"IFCCONSTRUCTIONMATERIALRESOURCETYPE\",\r\n    488727124: \"IFCCONSTRUCTIONPRODUCTRESOURCE\",\r\n    1525564444: \"IFCCONSTRUCTIONPRODUCTRESOURCETYPE\",\r\n    2559216714: \"IFCCONSTRUCTIONRESOURCE\",\r\n    2574617495: \"IFCCONSTRUCTIONRESOURCETYPE\",\r\n    3419103109: \"IFCCONTEXT\",\r\n    3050246964: \"IFCCONTEXTDEPENDENTUNIT\",\r\n    3293443760: \"IFCCONTROL\",\r\n    25142252: \"IFCCONTROLLER\",\r\n    578613899: \"IFCCONTROLLERTYPE\",\r\n    2889183280: \"IFCCONVERSIONBASEDUNIT\",\r\n    2713554722: \"IFCCONVERSIONBASEDUNITWITHOFFSET\",\r\n    4136498852: \"IFCCOOLEDBEAM\",\r\n    335055490: \"IFCCOOLEDBEAMTYPE\",\r\n    3640358203: \"IFCCOOLINGTOWER\",\r\n    2954562838: \"IFCCOOLINGTOWERTYPE\",\r\n    1785450214: \"IFCCOORDINATEOPERATION\",\r\n    1466758467: \"IFCCOORDINATEREFERENCESYSTEM\",\r\n    3895139033: \"IFCCOSTITEM\",\r\n    1419761937: \"IFCCOSTSCHEDULE\",\r\n    602808272: \"IFCCOSTVALUE\",\r\n    1973544240: \"IFCCOVERING\",\r\n    1916426348: \"IFCCOVERINGTYPE\",\r\n    3295246426: \"IFCCREWRESOURCE\",\r\n    1815067380: \"IFCCREWRESOURCETYPE\",\r\n    2506170314: \"IFCCSGPRIMITIVE3D\",\r\n    2147822146: \"IFCCSGSOLID\",\r\n    539742890: \"IFCCURRENCYRELATIONSHIP\",\r\n    3495092785: \"IFCCURTAINWALL\",\r\n    1457835157: \"IFCCURTAINWALLTYPE\",\r\n    2601014836: \"IFCCURVE\",\r\n    2827736869: \"IFCCURVEBOUNDEDPLANE\",\r\n    2629017746: \"IFCCURVEBOUNDEDSURFACE\",\r\n    1186437898: \"IFCCURVESEGMENT2D\",\r\n    3800577675: \"IFCCURVESTYLE\",\r\n    1105321065: \"IFCCURVESTYLEFONT\",\r\n    2367409068: \"IFCCURVESTYLEFONTANDSCALING\",\r\n    3510044353: \"IFCCURVESTYLEFONTPATTERN\",\r\n    1213902940: \"IFCCYLINDRICALSURFACE\",\r\n    4074379575: \"IFCDAMPER\",\r\n    3961806047: \"IFCDAMPERTYPE\",\r\n    3426335179: \"IFCDEEPFOUNDATION\",\r\n    1306400036: \"IFCDEEPFOUNDATIONTYPE\",\r\n    3632507154: \"IFCDERIVEDPROFILEDEF\",\r\n    1765591967: \"IFCDERIVEDUNIT\",\r\n    1045800335: \"IFCDERIVEDUNITELEMENT\",\r\n    2949456006: \"IFCDIMENSIONALEXPONENTS\",\r\n    32440307: \"IFCDIRECTION\",\r\n    1335981549: \"IFCDISCRETEACCESSORY\",\r\n    2635815018: \"IFCDISCRETEACCESSORYTYPE\",\r\n    1945343521: \"IFCDISTANCEEXPRESSION\",\r\n    1052013943: \"IFCDISTRIBUTIONCHAMBERELEMENT\",\r\n    1599208980: \"IFCDISTRIBUTIONCHAMBERELEMENTTYPE\",\r\n    562808652: \"IFCDISTRIBUTIONCIRCUIT\",\r\n    1062813311: \"IFCDISTRIBUTIONCONTROLELEMENT\",\r\n    2063403501: \"IFCDISTRIBUTIONCONTROLELEMENTTYPE\",\r\n    1945004755: \"IFCDISTRIBUTIONELEMENT\",\r\n    3256556792: \"IFCDISTRIBUTIONELEMENTTYPE\",\r\n    3040386961: \"IFCDISTRIBUTIONFLOWELEMENT\",\r\n    3849074793: \"IFCDISTRIBUTIONFLOWELEMENTTYPE\",\r\n    3041715199: \"IFCDISTRIBUTIONPORT\",\r\n    3205830791: \"IFCDISTRIBUTIONSYSTEM\",\r\n    1154170062: \"IFCDOCUMENTINFORMATION\",\r\n    770865208: \"IFCDOCUMENTINFORMATIONRELATIONSHIP\",\r\n    3732053477: \"IFCDOCUMENTREFERENCE\",\r\n    395920057: \"IFCDOOR\",\r\n    2963535650: \"IFCDOORLININGPROPERTIES\",\r\n    1714330368: \"IFCDOORPANELPROPERTIES\",\r\n    3242481149: \"IFCDOORSTANDARDCASE\",\r\n    526551008: \"IFCDOORSTYLE\",\r\n    2323601079: \"IFCDOORTYPE\",\r\n    445594917: \"IFCDRAUGHTINGPREDEFINEDCOLOUR\",\r\n    4006246654: \"IFCDRAUGHTINGPREDEFINEDCURVEFONT\",\r\n    342316401: \"IFCDUCTFITTING\",\r\n    869906466: \"IFCDUCTFITTINGTYPE\",\r\n    3518393246: \"IFCDUCTSEGMENT\",\r\n    3760055223: \"IFCDUCTSEGMENTTYPE\",\r\n    1360408905: \"IFCDUCTSILENCER\",\r\n    2030761528: \"IFCDUCTSILENCERTYPE\",\r\n    3900360178: \"IFCEDGE\",\r\n    476780140: \"IFCEDGECURVE\",\r\n    1472233963: \"IFCEDGELOOP\",\r\n    1904799276: \"IFCELECTRICAPPLIANCE\",\r\n    663422040: \"IFCELECTRICAPPLIANCETYPE\",\r\n    862014818: \"IFCELECTRICDISTRIBUTIONBOARD\",\r\n    2417008758: \"IFCELECTRICDISTRIBUTIONBOARDTYPE\",\r\n    3310460725: \"IFCELECTRICFLOWSTORAGEDEVICE\",\r\n    3277789161: \"IFCELECTRICFLOWSTORAGEDEVICETYPE\",\r\n    264262732: \"IFCELECTRICGENERATOR\",\r\n    1534661035: \"IFCELECTRICGENERATORTYPE\",\r\n    402227799: \"IFCELECTRICMOTOR\",\r\n    1217240411: \"IFCELECTRICMOTORTYPE\",\r\n    1003880860: \"IFCELECTRICTIMECONTROL\",\r\n    712377611: \"IFCELECTRICTIMECONTROLTYPE\",\r\n    1758889154: \"IFCELEMENT\",\r\n    4123344466: \"IFCELEMENTASSEMBLY\",\r\n    2397081782: \"IFCELEMENTASSEMBLYTYPE\",\r\n    1623761950: \"IFCELEMENTCOMPONENT\",\r\n    2590856083: \"IFCELEMENTCOMPONENTTYPE\",\r\n    1883228015: \"IFCELEMENTQUANTITY\",\r\n    339256511: \"IFCELEMENTTYPE\",\r\n    2777663545: \"IFCELEMENTARYSURFACE\",\r\n    1704287377: \"IFCELLIPSE\",\r\n    2835456948: \"IFCELLIPSEPROFILEDEF\",\r\n    1658829314: \"IFCENERGYCONVERSIONDEVICE\",\r\n    2107101300: \"IFCENERGYCONVERSIONDEVICETYPE\",\r\n    2814081492: \"IFCENGINE\",\r\n    132023988: \"IFCENGINETYPE\",\r\n    3747195512: \"IFCEVAPORATIVECOOLER\",\r\n    3174744832: \"IFCEVAPORATIVECOOLERTYPE\",\r\n    484807127: \"IFCEVAPORATOR\",\r\n    3390157468: \"IFCEVAPORATORTYPE\",\r\n    4148101412: \"IFCEVENT\",\r\n    211053100: \"IFCEVENTTIME\",\r\n    4024345920: \"IFCEVENTTYPE\",\r\n    297599258: \"IFCEXTENDEDPROPERTIES\",\r\n    4294318154: \"IFCEXTERNALINFORMATION\",\r\n    3200245327: \"IFCEXTERNALREFERENCE\",\r\n    1437805879: \"IFCEXTERNALREFERENCERELATIONSHIP\",\r\n    1209101575: \"IFCEXTERNALSPATIALELEMENT\",\r\n    2853485674: \"IFCEXTERNALSPATIALSTRUCTUREELEMENT\",\r\n    2242383968: \"IFCEXTERNALLYDEFINEDHATCHSTYLE\",\r\n    1040185647: \"IFCEXTERNALLYDEFINEDSURFACESTYLE\",\r\n    3548104201: \"IFCEXTERNALLYDEFINEDTEXTFONT\",\r\n    477187591: \"IFCEXTRUDEDAREASOLID\",\r\n    2804161546: \"IFCEXTRUDEDAREASOLIDTAPERED\",\r\n    2556980723: \"IFCFACE\",\r\n    2047409740: \"IFCFACEBASEDSURFACEMODEL\",\r\n    1809719519: \"IFCFACEBOUND\",\r\n    803316827: \"IFCFACEOUTERBOUND\",\r\n    3008276851: \"IFCFACESURFACE\",\r\n    807026263: \"IFCFACETEDBREP\",\r\n    3737207727: \"IFCFACETEDBREPWITHVOIDS\",\r\n    24185140: \"IFCFACILITY\",\r\n    1310830890: \"IFCFACILITYPART\",\r\n    4219587988: \"IFCFAILURECONNECTIONCONDITION\",\r\n    3415622556: \"IFCFAN\",\r\n    346874300: \"IFCFANTYPE\",\r\n    647756555: \"IFCFASTENER\",\r\n    2489546625: \"IFCFASTENERTYPE\",\r\n    2827207264: \"IFCFEATUREELEMENT\",\r\n    2143335405: \"IFCFEATUREELEMENTADDITION\",\r\n    1287392070: \"IFCFEATUREELEMENTSUBTRACTION\",\r\n    738692330: \"IFCFILLAREASTYLE\",\r\n    374418227: \"IFCFILLAREASTYLEHATCHING\",\r\n    315944413: \"IFCFILLAREASTYLETILES\",\r\n    819412036: \"IFCFILTER\",\r\n    1810631287: \"IFCFILTERTYPE\",\r\n    1426591983: \"IFCFIRESUPPRESSIONTERMINAL\",\r\n    4222183408: \"IFCFIRESUPPRESSIONTERMINALTYPE\",\r\n    2652556860: \"IFCFIXEDREFERENCESWEPTAREASOLID\",\r\n    2058353004: \"IFCFLOWCONTROLLER\",\r\n    3907093117: \"IFCFLOWCONTROLLERTYPE\",\r\n    4278956645: \"IFCFLOWFITTING\",\r\n    3198132628: \"IFCFLOWFITTINGTYPE\",\r\n    182646315: \"IFCFLOWINSTRUMENT\",\r\n    4037862832: \"IFCFLOWINSTRUMENTTYPE\",\r\n    2188021234: \"IFCFLOWMETER\",\r\n    3815607619: \"IFCFLOWMETERTYPE\",\r\n    3132237377: \"IFCFLOWMOVINGDEVICE\",\r\n    1482959167: \"IFCFLOWMOVINGDEVICETYPE\",\r\n    987401354: \"IFCFLOWSEGMENT\",\r\n    1834744321: \"IFCFLOWSEGMENTTYPE\",\r\n    707683696: \"IFCFLOWSTORAGEDEVICE\",\r\n    1339347760: \"IFCFLOWSTORAGEDEVICETYPE\",\r\n    2223149337: \"IFCFLOWTERMINAL\",\r\n    2297155007: \"IFCFLOWTERMINALTYPE\",\r\n    3508470533: \"IFCFLOWTREATMENTDEVICE\",\r\n    3009222698: \"IFCFLOWTREATMENTDEVICETYPE\",\r\n    900683007: \"IFCFOOTING\",\r\n    1893162501: \"IFCFOOTINGTYPE\",\r\n    263784265: \"IFCFURNISHINGELEMENT\",\r\n    4238390223: \"IFCFURNISHINGELEMENTTYPE\",\r\n    1509553395: \"IFCFURNITURE\",\r\n    1268542332: \"IFCFURNITURETYPE\",\r\n    3493046030: \"IFCGEOGRAPHICELEMENT\",\r\n    4095422895: \"IFCGEOGRAPHICELEMENTTYPE\",\r\n    987898635: \"IFCGEOMETRICCURVESET\",\r\n    3448662350: \"IFCGEOMETRICREPRESENTATIONCONTEXT\",\r\n    2453401579: \"IFCGEOMETRICREPRESENTATIONITEM\",\r\n    4142052618: \"IFCGEOMETRICREPRESENTATIONSUBCONTEXT\",\r\n    3590301190: \"IFCGEOMETRICSET\",\r\n    3009204131: \"IFCGRID\",\r\n    852622518: \"IFCGRIDAXIS\",\r\n    178086475: \"IFCGRIDPLACEMENT\",\r\n    2706460486: \"IFCGROUP\",\r\n    812098782: \"IFCHALFSPACESOLID\",\r\n    3319311131: \"IFCHEATEXCHANGER\",\r\n    1251058090: \"IFCHEATEXCHANGERTYPE\",\r\n    2068733104: \"IFCHUMIDIFIER\",\r\n    1806887404: \"IFCHUMIDIFIERTYPE\",\r\n    1484403080: \"IFCISHAPEPROFILEDEF\",\r\n    3905492369: \"IFCIMAGETEXTURE\",\r\n    3570813810: \"IFCINDEXEDCOLOURMAP\",\r\n    2571569899: \"IFCINDEXEDPOLYCURVE\",\r\n    178912537: \"IFCINDEXEDPOLYGONALFACE\",\r\n    2294589976: \"IFCINDEXEDPOLYGONALFACEWITHVOIDS\",\r\n    1437953363: \"IFCINDEXEDTEXTUREMAP\",\r\n    2133299955: \"IFCINDEXEDTRIANGLETEXTUREMAP\",\r\n    4175244083: \"IFCINTERCEPTOR\",\r\n    3946677679: \"IFCINTERCEPTORTYPE\",\r\n    3113134337: \"IFCINTERSECTIONCURVE\",\r\n    2391368822: \"IFCINVENTORY\",\r\n    3741457305: \"IFCIRREGULARTIMESERIES\",\r\n    3020489413: \"IFCIRREGULARTIMESERIESVALUE\",\r\n    2176052936: \"IFCJUNCTIONBOX\",\r\n    4288270099: \"IFCJUNCTIONBOXTYPE\",\r\n    572779678: \"IFCLSHAPEPROFILEDEF\",\r\n    3827777499: \"IFCLABORRESOURCE\",\r\n    428585644: \"IFCLABORRESOURCETYPE\",\r\n    1585845231: \"IFCLAGTIME\",\r\n    76236018: \"IFCLAMP\",\r\n    1051575348: \"IFCLAMPTYPE\",\r\n    2655187982: \"IFCLIBRARYINFORMATION\",\r\n    3452421091: \"IFCLIBRARYREFERENCE\",\r\n    4162380809: \"IFCLIGHTDISTRIBUTIONDATA\",\r\n    629592764: \"IFCLIGHTFIXTURE\",\r\n    1161773419: \"IFCLIGHTFIXTURETYPE\",\r\n    1566485204: \"IFCLIGHTINTENSITYDISTRIBUTION\",\r\n    1402838566: \"IFCLIGHTSOURCE\",\r\n    125510826: \"IFCLIGHTSOURCEAMBIENT\",\r\n    2604431987: \"IFCLIGHTSOURCEDIRECTIONAL\",\r\n    4266656042: \"IFCLIGHTSOURCEGONIOMETRIC\",\r\n    1520743889: \"IFCLIGHTSOURCEPOSITIONAL\",\r\n    3422422726: \"IFCLIGHTSOURCESPOT\",\r\n    1281925730: \"IFCLINE\",\r\n    3092502836: \"IFCLINESEGMENT2D\",\r\n    388784114: \"IFCLINEARPLACEMENT\",\r\n    1154579445: \"IFCLINEARPOSITIONINGELEMENT\",\r\n    2624227202: \"IFCLOCALPLACEMENT\",\r\n    1008929658: \"IFCLOOP\",\r\n    1425443689: \"IFCMANIFOLDSOLIDBREP\",\r\n    3057273783: \"IFCMAPCONVERSION\",\r\n    2347385850: \"IFCMAPPEDITEM\",\r\n    1838606355: \"IFCMATERIAL\",\r\n    1847130766: \"IFCMATERIALCLASSIFICATIONRELATIONSHIP\",\r\n    3708119000: \"IFCMATERIALCONSTITUENT\",\r\n    2852063980: \"IFCMATERIALCONSTITUENTSET\",\r\n    760658860: \"IFCMATERIALDEFINITION\",\r\n    2022407955: \"IFCMATERIALDEFINITIONREPRESENTATION\",\r\n    248100487: \"IFCMATERIALLAYER\",\r\n    3303938423: \"IFCMATERIALLAYERSET\",\r\n    1303795690: \"IFCMATERIALLAYERSETUSAGE\",\r\n    1847252529: \"IFCMATERIALLAYERWITHOFFSETS\",\r\n    2199411900: \"IFCMATERIALLIST\",\r\n    2235152071: \"IFCMATERIALPROFILE\",\r\n    164193824: \"IFCMATERIALPROFILESET\",\r\n    3079605661: \"IFCMATERIALPROFILESETUSAGE\",\r\n    3404854881: \"IFCMATERIALPROFILESETUSAGETAPERING\",\r\n    552965576: \"IFCMATERIALPROFILEWITHOFFSETS\",\r\n    3265635763: \"IFCMATERIALPROPERTIES\",\r\n    853536259: \"IFCMATERIALRELATIONSHIP\",\r\n    1507914824: \"IFCMATERIALUSAGEDEFINITION\",\r\n    2597039031: \"IFCMEASUREWITHUNIT\",\r\n    377706215: \"IFCMECHANICALFASTENER\",\r\n    2108223431: \"IFCMECHANICALFASTENERTYPE\",\r\n    1437502449: \"IFCMEDICALDEVICE\",\r\n    1114901282: \"IFCMEDICALDEVICETYPE\",\r\n    1073191201: \"IFCMEMBER\",\r\n    1911478936: \"IFCMEMBERSTANDARDCASE\",\r\n    3181161470: \"IFCMEMBERTYPE\",\r\n    3368373690: \"IFCMETRIC\",\r\n    2998442950: \"IFCMIRROREDPROFILEDEF\",\r\n    2706619895: \"IFCMONETARYUNIT\",\r\n    2474470126: \"IFCMOTORCONNECTION\",\r\n    977012517: \"IFCMOTORCONNECTIONTYPE\",\r\n    1918398963: \"IFCNAMEDUNIT\",\r\n    3888040117: \"IFCOBJECT\",\r\n    219451334: \"IFCOBJECTDEFINITION\",\r\n    3701648758: \"IFCOBJECTPLACEMENT\",\r\n    2251480897: \"IFCOBJECTIVE\",\r\n    4143007308: \"IFCOCCUPANT\",\r\n    590820931: \"IFCOFFSETCURVE\",\r\n    3388369263: \"IFCOFFSETCURVE2D\",\r\n    3505215534: \"IFCOFFSETCURVE3D\",\r\n    2485787929: \"IFCOFFSETCURVEBYDISTANCES\",\r\n    2665983363: \"IFCOPENSHELL\",\r\n    3588315303: \"IFCOPENINGELEMENT\",\r\n    3079942009: \"IFCOPENINGSTANDARDCASE\",\r\n    4251960020: \"IFCORGANIZATION\",\r\n    1411181986: \"IFCORGANIZATIONRELATIONSHIP\",\r\n    643959842: \"IFCORIENTATIONEXPRESSION\",\r\n    1029017970: \"IFCORIENTEDEDGE\",\r\n    144952367: \"IFCOUTERBOUNDARYCURVE\",\r\n    3694346114: \"IFCOUTLET\",\r\n    2837617999: \"IFCOUTLETTYPE\",\r\n    1207048766: \"IFCOWNERHISTORY\",\r\n    2529465313: \"IFCPARAMETERIZEDPROFILEDEF\",\r\n    2519244187: \"IFCPATH\",\r\n    1682466193: \"IFCPCURVE\",\r\n    2382730787: \"IFCPERFORMANCEHISTORY\",\r\n    3566463478: \"IFCPERMEABLECOVERINGPROPERTIES\",\r\n    3327091369: \"IFCPERMIT\",\r\n    2077209135: \"IFCPERSON\",\r\n    101040310: \"IFCPERSONANDORGANIZATION\",\r\n    3021840470: \"IFCPHYSICALCOMPLEXQUANTITY\",\r\n    2483315170: \"IFCPHYSICALQUANTITY\",\r\n    2226359599: \"IFCPHYSICALSIMPLEQUANTITY\",\r\n    1687234759: \"IFCPILE\",\r\n    1158309216: \"IFCPILETYPE\",\r\n    310824031: \"IFCPIPEFITTING\",\r\n    804291784: \"IFCPIPEFITTINGTYPE\",\r\n    3612865200: \"IFCPIPESEGMENT\",\r\n    4231323485: \"IFCPIPESEGMENTTYPE\",\r\n    597895409: \"IFCPIXELTEXTURE\",\r\n    2004835150: \"IFCPLACEMENT\",\r\n    603570806: \"IFCPLANARBOX\",\r\n    1663979128: \"IFCPLANAREXTENT\",\r\n    220341763: \"IFCPLANE\",\r\n    3171933400: \"IFCPLATE\",\r\n    1156407060: \"IFCPLATESTANDARDCASE\",\r\n    4017108033: \"IFCPLATETYPE\",\r\n    2067069095: \"IFCPOINT\",\r\n    4022376103: \"IFCPOINTONCURVE\",\r\n    1423911732: \"IFCPOINTONSURFACE\",\r\n    2924175390: \"IFCPOLYLOOP\",\r\n    2775532180: \"IFCPOLYGONALBOUNDEDHALFSPACE\",\r\n    2839578677: \"IFCPOLYGONALFACESET\",\r\n    3724593414: \"IFCPOLYLINE\",\r\n    3740093272: \"IFCPORT\",\r\n    1946335990: \"IFCPOSITIONINGELEMENT\",\r\n    3355820592: \"IFCPOSTALADDRESS\",\r\n    759155922: \"IFCPREDEFINEDCOLOUR\",\r\n    2559016684: \"IFCPREDEFINEDCURVEFONT\",\r\n    3727388367: \"IFCPREDEFINEDITEM\",\r\n    3778827333: \"IFCPREDEFINEDPROPERTIES\",\r\n    3967405729: \"IFCPREDEFINEDPROPERTYSET\",\r\n    1775413392: \"IFCPREDEFINEDTEXTFONT\",\r\n    677532197: \"IFCPRESENTATIONITEM\",\r\n    2022622350: \"IFCPRESENTATIONLAYERASSIGNMENT\",\r\n    1304840413: \"IFCPRESENTATIONLAYERWITHSTYLE\",\r\n    3119450353: \"IFCPRESENTATIONSTYLE\",\r\n    2417041796: \"IFCPRESENTATIONSTYLEASSIGNMENT\",\r\n    2744685151: \"IFCPROCEDURE\",\r\n    569719735: \"IFCPROCEDURETYPE\",\r\n    2945172077: \"IFCPROCESS\",\r\n    4208778838: \"IFCPRODUCT\",\r\n    673634403: \"IFCPRODUCTDEFINITIONSHAPE\",\r\n    2095639259: \"IFCPRODUCTREPRESENTATION\",\r\n    3958567839: \"IFCPROFILEDEF\",\r\n    2802850158: \"IFCPROFILEPROPERTIES\",\r\n    103090709: \"IFCPROJECT\",\r\n    653396225: \"IFCPROJECTLIBRARY\",\r\n    2904328755: \"IFCPROJECTORDER\",\r\n    3843373140: \"IFCPROJECTEDCRS\",\r\n    3651124850: \"IFCPROJECTIONELEMENT\",\r\n    2598011224: \"IFCPROPERTY\",\r\n    986844984: \"IFCPROPERTYABSTRACTION\",\r\n    871118103: \"IFCPROPERTYBOUNDEDVALUE\",\r\n    1680319473: \"IFCPROPERTYDEFINITION\",\r\n    148025276: \"IFCPROPERTYDEPENDENCYRELATIONSHIP\",\r\n    4166981789: \"IFCPROPERTYENUMERATEDVALUE\",\r\n    3710013099: \"IFCPROPERTYENUMERATION\",\r\n    2752243245: \"IFCPROPERTYLISTVALUE\",\r\n    941946838: \"IFCPROPERTYREFERENCEVALUE\",\r\n    1451395588: \"IFCPROPERTYSET\",\r\n    3357820518: \"IFCPROPERTYSETDEFINITION\",\r\n    492091185: \"IFCPROPERTYSETTEMPLATE\",\r\n    3650150729: \"IFCPROPERTYSINGLEVALUE\",\r\n    110355661: \"IFCPROPERTYTABLEVALUE\",\r\n    3521284610: \"IFCPROPERTYTEMPLATE\",\r\n    1482703590: \"IFCPROPERTYTEMPLATEDEFINITION\",\r\n    738039164: \"IFCPROTECTIVEDEVICE\",\r\n    2295281155: \"IFCPROTECTIVEDEVICETRIPPINGUNIT\",\r\n    655969474: \"IFCPROTECTIVEDEVICETRIPPINGUNITTYPE\",\r\n    1842657554: \"IFCPROTECTIVEDEVICETYPE\",\r\n    3219374653: \"IFCPROXY\",\r\n    90941305: \"IFCPUMP\",\r\n    2250791053: \"IFCPUMPTYPE\",\r\n    2044713172: \"IFCQUANTITYAREA\",\r\n    2093928680: \"IFCQUANTITYCOUNT\",\r\n    931644368: \"IFCQUANTITYLENGTH\",\r\n    2090586900: \"IFCQUANTITYSET\",\r\n    3252649465: \"IFCQUANTITYTIME\",\r\n    2405470396: \"IFCQUANTITYVOLUME\",\r\n    825690147: \"IFCQUANTITYWEIGHT\",\r\n    2262370178: \"IFCRAILING\",\r\n    2893384427: \"IFCRAILINGTYPE\",\r\n    3024970846: \"IFCRAMP\",\r\n    3283111854: \"IFCRAMPFLIGHT\",\r\n    2324767716: \"IFCRAMPFLIGHTTYPE\",\r\n    1469900589: \"IFCRAMPTYPE\",\r\n    1232101972: \"IFCRATIONALBSPLINECURVEWITHKNOTS\",\r\n    683857671: \"IFCRATIONALBSPLINESURFACEWITHKNOTS\",\r\n    2770003689: \"IFCRECTANGLEHOLLOWPROFILEDEF\",\r\n    3615266464: \"IFCRECTANGLEPROFILEDEF\",\r\n    2798486643: \"IFCRECTANGULARPYRAMID\",\r\n    3454111270: \"IFCRECTANGULARTRIMMEDSURFACE\",\r\n    3915482550: \"IFCRECURRENCEPATTERN\",\r\n    2433181523: \"IFCREFERENCE\",\r\n    4021432810: \"IFCREFERENT\",\r\n    3413951693: \"IFCREGULARTIMESERIES\",\r\n    1580146022: \"IFCREINFORCEMENTBARPROPERTIES\",\r\n    3765753017: \"IFCREINFORCEMENTDEFINITIONPROPERTIES\",\r\n    979691226: \"IFCREINFORCINGBAR\",\r\n    2572171363: \"IFCREINFORCINGBARTYPE\",\r\n    3027567501: \"IFCREINFORCINGELEMENT\",\r\n    964333572: \"IFCREINFORCINGELEMENTTYPE\",\r\n    2320036040: \"IFCREINFORCINGMESH\",\r\n    2310774935: \"IFCREINFORCINGMESHTYPE\",\r\n    160246688: \"IFCRELAGGREGATES\",\r\n    3939117080: \"IFCRELASSIGNS\",\r\n    1683148259: \"IFCRELASSIGNSTOACTOR\",\r\n    2495723537: \"IFCRELASSIGNSTOCONTROL\",\r\n    1307041759: \"IFCRELASSIGNSTOGROUP\",\r\n    1027710054: \"IFCRELASSIGNSTOGROUPBYFACTOR\",\r\n    4278684876: \"IFCRELASSIGNSTOPROCESS\",\r\n    2857406711: \"IFCRELASSIGNSTOPRODUCT\",\r\n    205026976: \"IFCRELASSIGNSTORESOURCE\",\r\n    1865459582: \"IFCRELASSOCIATES\",\r\n    4095574036: \"IFCRELASSOCIATESAPPROVAL\",\r\n    919958153: \"IFCRELASSOCIATESCLASSIFICATION\",\r\n    2728634034: \"IFCRELASSOCIATESCONSTRAINT\",\r\n    982818633: \"IFCRELASSOCIATESDOCUMENT\",\r\n    3840914261: \"IFCRELASSOCIATESLIBRARY\",\r\n    2655215786: \"IFCRELASSOCIATESMATERIAL\",\r\n    826625072: \"IFCRELCONNECTS\",\r\n    1204542856: \"IFCRELCONNECTSELEMENTS\",\r\n    3945020480: \"IFCRELCONNECTSPATHELEMENTS\",\r\n    4201705270: \"IFCRELCONNECTSPORTTOELEMENT\",\r\n    3190031847: \"IFCRELCONNECTSPORTS\",\r\n    2127690289: \"IFCRELCONNECTSSTRUCTURALACTIVITY\",\r\n    1638771189: \"IFCRELCONNECTSSTRUCTURALMEMBER\",\r\n    504942748: \"IFCRELCONNECTSWITHECCENTRICITY\",\r\n    3678494232: \"IFCRELCONNECTSWITHREALIZINGELEMENTS\",\r\n    3242617779: \"IFCRELCONTAINEDINSPATIALSTRUCTURE\",\r\n    886880790: \"IFCRELCOVERSBLDGELEMENTS\",\r\n    2802773753: \"IFCRELCOVERSSPACES\",\r\n    2565941209: \"IFCRELDECLARES\",\r\n    2551354335: \"IFCRELDECOMPOSES\",\r\n    693640335: \"IFCRELDEFINES\",\r\n    1462361463: \"IFCRELDEFINESBYOBJECT\",\r\n    4186316022: \"IFCRELDEFINESBYPROPERTIES\",\r\n    307848117: \"IFCRELDEFINESBYTEMPLATE\",\r\n    781010003: \"IFCRELDEFINESBYTYPE\",\r\n    3940055652: \"IFCRELFILLSELEMENT\",\r\n    279856033: \"IFCRELFLOWCONTROLELEMENTS\",\r\n    427948657: \"IFCRELINTERFERESELEMENTS\",\r\n    3268803585: \"IFCRELNESTS\",\r\n    1441486842: \"IFCRELPOSITIONS\",\r\n    750771296: \"IFCRELPROJECTSELEMENT\",\r\n    1245217292: \"IFCRELREFERENCEDINSPATIALSTRUCTURE\",\r\n    4122056220: \"IFCRELSEQUENCE\",\r\n    366585022: \"IFCRELSERVICESBUILDINGS\",\r\n    3451746338: \"IFCRELSPACEBOUNDARY\",\r\n    3523091289: \"IFCRELSPACEBOUNDARY1STLEVEL\",\r\n    1521410863: \"IFCRELSPACEBOUNDARY2NDLEVEL\",\r\n    1401173127: \"IFCRELVOIDSELEMENT\",\r\n    478536968: \"IFCRELATIONSHIP\",\r\n    816062949: \"IFCREPARAMETRISEDCOMPOSITECURVESEGMENT\",\r\n    1076942058: \"IFCREPRESENTATION\",\r\n    3377609919: \"IFCREPRESENTATIONCONTEXT\",\r\n    3008791417: \"IFCREPRESENTATIONITEM\",\r\n    1660063152: \"IFCREPRESENTATIONMAP\",\r\n    2914609552: \"IFCRESOURCE\",\r\n    2943643501: \"IFCRESOURCEAPPROVALRELATIONSHIP\",\r\n    1608871552: \"IFCRESOURCECONSTRAINTRELATIONSHIP\",\r\n    2439245199: \"IFCRESOURCELEVELRELATIONSHIP\",\r\n    1042787934: \"IFCRESOURCETIME\",\r\n    1856042241: \"IFCREVOLVEDAREASOLID\",\r\n    3243963512: \"IFCREVOLVEDAREASOLIDTAPERED\",\r\n    4158566097: \"IFCRIGHTCIRCULARCONE\",\r\n    3626867408: \"IFCRIGHTCIRCULARCYLINDER\",\r\n    2016517767: \"IFCROOF\",\r\n    2781568857: \"IFCROOFTYPE\",\r\n    2341007311: \"IFCROOT\",\r\n    2778083089: \"IFCROUNDEDRECTANGLEPROFILEDEF\",\r\n    448429030: \"IFCSIUNIT\",\r\n    3053780830: \"IFCSANITARYTERMINAL\",\r\n    1768891740: \"IFCSANITARYTERMINALTYPE\",\r\n    1054537805: \"IFCSCHEDULINGTIME\",\r\n    2157484638: \"IFCSEAMCURVE\",\r\n    2042790032: \"IFCSECTIONPROPERTIES\",\r\n    4165799628: \"IFCSECTIONREINFORCEMENTPROPERTIES\",\r\n    1862484736: \"IFCSECTIONEDSOLID\",\r\n    1290935644: \"IFCSECTIONEDSOLIDHORIZONTAL\",\r\n    1509187699: \"IFCSECTIONEDSPINE\",\r\n    4086658281: \"IFCSENSOR\",\r\n    1783015770: \"IFCSENSORTYPE\",\r\n    1329646415: \"IFCSHADINGDEVICE\",\r\n    4074543187: \"IFCSHADINGDEVICETYPE\",\r\n    867548509: \"IFCSHAPEASPECT\",\r\n    3982875396: \"IFCSHAPEMODEL\",\r\n    4240577450: \"IFCSHAPEREPRESENTATION\",\r\n    4124623270: \"IFCSHELLBASEDSURFACEMODEL\",\r\n    3692461612: \"IFCSIMPLEPROPERTY\",\r\n    3663146110: \"IFCSIMPLEPROPERTYTEMPLATE\",\r\n    4097777520: \"IFCSITE\",\r\n    1529196076: \"IFCSLAB\",\r\n    3127900445: \"IFCSLABELEMENTEDCASE\",\r\n    3027962421: \"IFCSLABSTANDARDCASE\",\r\n    2533589738: \"IFCSLABTYPE\",\r\n    2609359061: \"IFCSLIPPAGECONNECTIONCONDITION\",\r\n    3420628829: \"IFCSOLARDEVICE\",\r\n    1072016465: \"IFCSOLARDEVICETYPE\",\r\n    723233188: \"IFCSOLIDMODEL\",\r\n    3856911033: \"IFCSPACE\",\r\n    1999602285: \"IFCSPACEHEATER\",\r\n    1305183839: \"IFCSPACEHEATERTYPE\",\r\n    3812236995: \"IFCSPACETYPE\",\r\n    1412071761: \"IFCSPATIALELEMENT\",\r\n    710998568: \"IFCSPATIALELEMENTTYPE\",\r\n    2706606064: \"IFCSPATIALSTRUCTUREELEMENT\",\r\n    3893378262: \"IFCSPATIALSTRUCTUREELEMENTTYPE\",\r\n    463610769: \"IFCSPATIALZONE\",\r\n    2481509218: \"IFCSPATIALZONETYPE\",\r\n    451544542: \"IFCSPHERE\",\r\n    4015995234: \"IFCSPHERICALSURFACE\",\r\n    1404847402: \"IFCSTACKTERMINAL\",\r\n    3112655638: \"IFCSTACKTERMINALTYPE\",\r\n    331165859: \"IFCSTAIR\",\r\n    4252922144: \"IFCSTAIRFLIGHT\",\r\n    1039846685: \"IFCSTAIRFLIGHTTYPE\",\r\n    338393293: \"IFCSTAIRTYPE\",\r\n    682877961: \"IFCSTRUCTURALACTION\",\r\n    3544373492: \"IFCSTRUCTURALACTIVITY\",\r\n    2515109513: \"IFCSTRUCTURALANALYSISMODEL\",\r\n    1179482911: \"IFCSTRUCTURALCONNECTION\",\r\n    2273995522: \"IFCSTRUCTURALCONNECTIONCONDITION\",\r\n    1004757350: \"IFCSTRUCTURALCURVEACTION\",\r\n    4243806635: \"IFCSTRUCTURALCURVECONNECTION\",\r\n    214636428: \"IFCSTRUCTURALCURVEMEMBER\",\r\n    2445595289: \"IFCSTRUCTURALCURVEMEMBERVARYING\",\r\n    2757150158: \"IFCSTRUCTURALCURVEREACTION\",\r\n    3136571912: \"IFCSTRUCTURALITEM\",\r\n    1807405624: \"IFCSTRUCTURALLINEARACTION\",\r\n    2162789131: \"IFCSTRUCTURALLOAD\",\r\n    385403989: \"IFCSTRUCTURALLOADCASE\",\r\n    3478079324: \"IFCSTRUCTURALLOADCONFIGURATION\",\r\n    1252848954: \"IFCSTRUCTURALLOADGROUP\",\r\n    1595516126: \"IFCSTRUCTURALLOADLINEARFORCE\",\r\n    609421318: \"IFCSTRUCTURALLOADORRESULT\",\r\n    2668620305: \"IFCSTRUCTURALLOADPLANARFORCE\",\r\n    2473145415: \"IFCSTRUCTURALLOADSINGLEDISPLACEMENT\",\r\n    1973038258: \"IFCSTRUCTURALLOADSINGLEDISPLACEMENTDISTORTION\",\r\n    1597423693: \"IFCSTRUCTURALLOADSINGLEFORCE\",\r\n    1190533807: \"IFCSTRUCTURALLOADSINGLEFORCEWARPING\",\r\n    2525727697: \"IFCSTRUCTURALLOADSTATIC\",\r\n    3408363356: \"IFCSTRUCTURALLOADTEMPERATURE\",\r\n    530289379: \"IFCSTRUCTURALMEMBER\",\r\n    1621171031: \"IFCSTRUCTURALPLANARACTION\",\r\n    2082059205: \"IFCSTRUCTURALPOINTACTION\",\r\n    734778138: \"IFCSTRUCTURALPOINTCONNECTION\",\r\n    1235345126: \"IFCSTRUCTURALPOINTREACTION\",\r\n    3689010777: \"IFCSTRUCTURALREACTION\",\r\n    2986769608: \"IFCSTRUCTURALRESULTGROUP\",\r\n    3657597509: \"IFCSTRUCTURALSURFACEACTION\",\r\n    1975003073: \"IFCSTRUCTURALSURFACECONNECTION\",\r\n    3979015343: \"IFCSTRUCTURALSURFACEMEMBER\",\r\n    2218152070: \"IFCSTRUCTURALSURFACEMEMBERVARYING\",\r\n    603775116: \"IFCSTRUCTURALSURFACEREACTION\",\r\n    2830218821: \"IFCSTYLEMODEL\",\r\n    3958052878: \"IFCSTYLEDITEM\",\r\n    3049322572: \"IFCSTYLEDREPRESENTATION\",\r\n    148013059: \"IFCSUBCONTRACTRESOURCE\",\r\n    4095615324: \"IFCSUBCONTRACTRESOURCETYPE\",\r\n    2233826070: \"IFCSUBEDGE\",\r\n    2513912981: \"IFCSURFACE\",\r\n    699246055: \"IFCSURFACECURVE\",\r\n    2028607225: \"IFCSURFACECURVESWEPTAREASOLID\",\r\n    3101698114: \"IFCSURFACEFEATURE\",\r\n    2809605785: \"IFCSURFACEOFLINEAREXTRUSION\",\r\n    4124788165: \"IFCSURFACEOFREVOLUTION\",\r\n    2934153892: \"IFCSURFACEREINFORCEMENTAREA\",\r\n    1300840506: \"IFCSURFACESTYLE\",\r\n    3303107099: \"IFCSURFACESTYLELIGHTING\",\r\n    1607154358: \"IFCSURFACESTYLEREFRACTION\",\r\n    1878645084: \"IFCSURFACESTYLERENDERING\",\r\n    846575682: \"IFCSURFACESTYLESHADING\",\r\n    1351298697: \"IFCSURFACESTYLEWITHTEXTURES\",\r\n    626085974: \"IFCSURFACETEXTURE\",\r\n    2247615214: \"IFCSWEPTAREASOLID\",\r\n    1260650574: \"IFCSWEPTDISKSOLID\",\r\n    1096409881: \"IFCSWEPTDISKSOLIDPOLYGONAL\",\r\n    230924584: \"IFCSWEPTSURFACE\",\r\n    1162798199: \"IFCSWITCHINGDEVICE\",\r\n    2315554128: \"IFCSWITCHINGDEVICETYPE\",\r\n    2254336722: \"IFCSYSTEM\",\r\n    413509423: \"IFCSYSTEMFURNITUREELEMENT\",\r\n    1580310250: \"IFCSYSTEMFURNITUREELEMENTTYPE\",\r\n    3071757647: \"IFCTSHAPEPROFILEDEF\",\r\n    985171141: \"IFCTABLE\",\r\n    2043862942: \"IFCTABLECOLUMN\",\r\n    531007025: \"IFCTABLEROW\",\r\n    812556717: \"IFCTANK\",\r\n    5716631: \"IFCTANKTYPE\",\r\n    3473067441: \"IFCTASK\",\r\n    1549132990: \"IFCTASKTIME\",\r\n    2771591690: \"IFCTASKTIMERECURRING\",\r\n    3206491090: \"IFCTASKTYPE\",\r\n    912023232: \"IFCTELECOMADDRESS\",\r\n    3824725483: \"IFCTENDON\",\r\n    2347447852: \"IFCTENDONANCHOR\",\r\n    3081323446: \"IFCTENDONANCHORTYPE\",\r\n    3663046924: \"IFCTENDONCONDUIT\",\r\n    2281632017: \"IFCTENDONCONDUITTYPE\",\r\n    2415094496: \"IFCTENDONTYPE\",\r\n    2387106220: \"IFCTESSELLATEDFACESET\",\r\n    901063453: \"IFCTESSELLATEDITEM\",\r\n    4282788508: \"IFCTEXTLITERAL\",\r\n    3124975700: \"IFCTEXTLITERALWITHEXTENT\",\r\n    1447204868: \"IFCTEXTSTYLE\",\r\n    1983826977: \"IFCTEXTSTYLEFONTMODEL\",\r\n    2636378356: \"IFCTEXTSTYLEFORDEFINEDFONT\",\r\n    1640371178: \"IFCTEXTSTYLETEXTMODEL\",\r\n    280115917: \"IFCTEXTURECOORDINATE\",\r\n    1742049831: \"IFCTEXTURECOORDINATEGENERATOR\",\r\n    2552916305: \"IFCTEXTUREMAP\",\r\n    1210645708: \"IFCTEXTUREVERTEX\",\r\n    3611470254: \"IFCTEXTUREVERTEXLIST\",\r\n    1199560280: \"IFCTIMEPERIOD\",\r\n    3101149627: \"IFCTIMESERIES\",\r\n    581633288: \"IFCTIMESERIESVALUE\",\r\n    1377556343: \"IFCTOPOLOGICALREPRESENTATIONITEM\",\r\n    1735638870: \"IFCTOPOLOGYREPRESENTATION\",\r\n    1935646853: \"IFCTOROIDALSURFACE\",\r\n    3825984169: \"IFCTRANSFORMER\",\r\n    1692211062: \"IFCTRANSFORMERTYPE\",\r\n    2595432518: \"IFCTRANSITIONCURVESEGMENT2D\",\r\n    1620046519: \"IFCTRANSPORTELEMENT\",\r\n    2097647324: \"IFCTRANSPORTELEMENTTYPE\",\r\n    2715220739: \"IFCTRAPEZIUMPROFILEDEF\",\r\n    2916149573: \"IFCTRIANGULATEDFACESET\",\r\n    1229763772: \"IFCTRIANGULATEDIRREGULARNETWORK\",\r\n    3593883385: \"IFCTRIMMEDCURVE\",\r\n    3026737570: \"IFCTUBEBUNDLE\",\r\n    1600972822: \"IFCTUBEBUNDLETYPE\",\r\n    1628702193: \"IFCTYPEOBJECT\",\r\n    3736923433: \"IFCTYPEPROCESS\",\r\n    2347495698: \"IFCTYPEPRODUCT\",\r\n    3698973494: \"IFCTYPERESOURCE\",\r\n    427810014: \"IFCUSHAPEPROFILEDEF\",\r\n    180925521: \"IFCUNITASSIGNMENT\",\r\n    630975310: \"IFCUNITARYCONTROLELEMENT\",\r\n    3179687236: \"IFCUNITARYCONTROLELEMENTTYPE\",\r\n    4292641817: \"IFCUNITARYEQUIPMENT\",\r\n    1911125066: \"IFCUNITARYEQUIPMENTTYPE\",\r\n    4207607924: \"IFCVALVE\",\r\n    728799441: \"IFCVALVETYPE\",\r\n    1417489154: \"IFCVECTOR\",\r\n    2799835756: \"IFCVERTEX\",\r\n    2759199220: \"IFCVERTEXLOOP\",\r\n    1907098498: \"IFCVERTEXPOINT\",\r\n    1530820697: \"IFCVIBRATIONDAMPER\",\r\n    3956297820: \"IFCVIBRATIONDAMPERTYPE\",\r\n    2391383451: \"IFCVIBRATIONISOLATOR\",\r\n    3313531582: \"IFCVIBRATIONISOLATORTYPE\",\r\n    2769231204: \"IFCVIRTUALELEMENT\",\r\n    891718957: \"IFCVIRTUALGRIDINTERSECTION\",\r\n    926996030: \"IFCVOIDINGFEATURE\",\r\n    2391406946: \"IFCWALL\",\r\n    4156078855: \"IFCWALLELEMENTEDCASE\",\r\n    3512223829: \"IFCWALLSTANDARDCASE\",\r\n    1898987631: \"IFCWALLTYPE\",\r\n    4237592921: \"IFCWASTETERMINAL\",\r\n    1133259667: \"IFCWASTETERMINALTYPE\",\r\n    3304561284: \"IFCWINDOW\",\r\n    336235671: \"IFCWINDOWLININGPROPERTIES\",\r\n    512836454: \"IFCWINDOWPANELPROPERTIES\",\r\n    486154966: \"IFCWINDOWSTANDARDCASE\",\r\n    1299126871: \"IFCWINDOWSTYLE\",\r\n    4009809668: \"IFCWINDOWTYPE\",\r\n    4088093105: \"IFCWORKCALENDAR\",\r\n    1028945134: \"IFCWORKCONTROL\",\r\n    4218914973: \"IFCWORKPLAN\",\r\n    3342526732: \"IFCWORKSCHEDULE\",\r\n    1236880293: \"IFCWORKTIME\",\r\n    2543172580: \"IFCZSHAPEPROFILEDEF\",\r\n    1033361043: \"IFCZONE\",\r\n}", "import { IfcTypesMap } from '../IfcTypesMap';\r\nimport { JSONObject, pName } from '../../BaseDefinitions';\r\nimport { BasePropertyManager } from './BasePropertyManager';\r\nimport { IFCPROJECT } from 'web-ifc';\r\nimport { PropertyAPI } from './BaseDefinitions';\r\n\r\nexport class JSONPropertyManager extends BasePropertyManager implements PropertyAPI {\r\n\r\n    async getItemProperties(modelID: number, id: number, recursive = false) {\r\n        return { ...this.state.models[modelID].jsonData[id] };\r\n    }\r\n\r\n    async getSpatialStructure(modelID: number, includeProperties?: boolean) {\r\n        const chunks = await this.getSpatialTreeChunks(modelID);\r\n        const projectsIDs = await this.getAllItemsOfType(modelID, IFCPROJECT, false);\r\n        const projectID = projectsIDs[0];\r\n        const project = JSONPropertyManager.newIfcProject(projectID);\r\n        await this.getSpatialNode(modelID, project, chunks, includeProperties);\r\n        return { ...project };\r\n    }\r\n\r\n    async getAllItemsOfType(modelID: number, type: number, verbose: boolean) {\r\n        const data = this.state.models[modelID].jsonData;\r\n        const typeName = IfcTypesMap[type];\r\n        if (!typeName) {\r\n            throw new Error(`Type not found: ${type}`);\r\n        }\r\n        return this.filterItemsByType(data, typeName, verbose);\r\n    }\r\n\r\n    override async getProperty(modelID: number, elementID: number, recursive = false, propName: pName) {\r\n        const resultIDs = await this.getAllRelatedItemsOfType(modelID, elementID, propName);\r\n        const result = this.getItemsByID(modelID, resultIDs);\r\n        if (recursive) {\r\n            result.forEach(result => this.getReferencesRecursively(modelID, result));\r\n        }\r\n        return result;\r\n    }\r\n\r\n    protected override getNodeType(modelID: number, id: number) {\r\n        return this.state.models[modelID].jsonData[id].type;\r\n    }\r\n\r\n    protected override async getChunks(modelID: number, chunks: any, propNames: pName) {\r\n        const relation = await this.getAllItemsOfType(modelID, propNames.name, true);\r\n        relation.forEach(rel => {\r\n            this.saveChunk(chunks, propNames, rel);\r\n        });\r\n    }\r\n\r\n    private filterItemsByType(data: { [id: number]: JSONObject }, typeName: string, verbose: boolean) {\r\n        const result: any[] = [];\r\n        Object.keys(data).forEach(key => {\r\n            const numKey = parseInt(key);\r\n            if (data[numKey].type.toUpperCase() === typeName) {\r\n                result.push(verbose ? { ...data[numKey] } : numKey);\r\n            }\r\n        });\r\n        return result;\r\n    }\r\n\r\n    private async getAllRelatedItemsOfType(modelID: number, id: number, propNames: pName) {\r\n        const lines = await this.getAllItemsOfType(modelID, propNames.name, true);\r\n        const IDs: number[] = [];\r\n        lines.forEach(line => {\r\n            const isRelated = JSONPropertyManager.isRelated(id, line, propNames);\r\n            if (isRelated) this.getRelated(line, propNames, IDs);\r\n        });\r\n        return IDs;\r\n    }\r\n\r\n    private getItemsByID(modelID: number, ids: number[]) {\r\n        const data = this.state.models[modelID].jsonData;\r\n        const result: any[] = [];\r\n        ids.forEach(id => result.push({ ...data[id] }));\r\n        return result;\r\n    }\r\n\r\n    private getReferencesRecursively(modelID: number, jsonObject: any) {\r\n        if (jsonObject == undefined) return;\r\n        const keys = Object.keys(jsonObject);\r\n        for (let i = 0; i < keys.length; i++) {\r\n            const key = keys[i];\r\n            this.getJSONItem(modelID, jsonObject, key);\r\n        }\r\n    }\r\n\r\n    private getJSONItem(modelID: number, jsonObject: any, key: string) {\r\n        if (Array.isArray(jsonObject[key])) {\r\n            return this.getMultipleJSONItems(modelID, jsonObject, key);\r\n        }\r\n        if (jsonObject[key] && jsonObject[key].type === 5) {\r\n            jsonObject[key] = this.getItemsByID(modelID, [jsonObject[key].value])[0];\r\n            this.getReferencesRecursively(modelID, jsonObject[key]);\r\n        }\r\n    }\r\n\r\n    private getMultipleJSONItems(modelID: number, jsonObject: any, key: string) {\r\n        jsonObject[key] = jsonObject[key].map((item: any) => {\r\n            if (item.type === 5) {\r\n                item = this.getItemsByID(modelID, [item.value])[0];\r\n                this.getReferencesRecursively(modelID, item);\r\n            }\r\n            return item;\r\n        });\r\n    }\r\n}", "export const geometryTypes = new Set<number>([\r\n  1123145078, 574549367, 1675464909, 2059837836, 3798115385, 32440307, 3125803723, 3207858831,\r\n  2740243338, 2624227202, 4240577450, 3615266464, 3724593414, 220341763, 477187591, 1878645084,\r\n  1300840506, 3303107099, 1607154358, 1878645084, 846575682, 1351298697, 2417041796, 3049322572,\r\n  3331915920, 1416205885, 776857604, 3285139300, 3958052878, 2827736869, 2732653382, 673634403,\r\n  3448662350, 4142052618, 2924175390, 803316827, 2556980723, 1809719519, 2205249479, 807026263,\r\n  3737207727, 1660063152, 2347385850, 3940055652, 2705031697, 3732776249, 2485617015, 2611217952,\r\n  1704287377, 2937912522, 2770003689, 1281925730, 1484403080, 3448662350, 4142052618, 3800577675,\r\n  4006246654, 3590301190, 1383045692, 2775532180, 2047409740, 370225590, 3593883385, 2665983363,\r\n  4124623270, 812098782, 3649129432, 987898635, 1105321065, 3510044353, 1635779807, 2603310189,\r\n  3406155212, 1310608509, 4261334040, 2736907675, 3649129432, 1136057603, 1260505505, 4182860854,\r\n  2713105998, 2898889636, 59481748, 3749851601, 3486308946, 3150382593, 1062206242, 3264961684,\r\n  15328376, 1485152156, 370225590, 1981873012, 2859738748, 45288368, 2614616156, 2732653382,\r\n  775493141, 2147822146, 2601014836, 2629017746, 1186437898, 2367409068, 1213902940, 3632507154,\r\n  3900360178, 476780140, 1472233963, 2804161546, 3008276851, 738692330, 374418227, 315944413,\r\n  3905492369, 3570813810, 2571569899, 178912537, 2294589976, 1437953363, 2133299955, 572779678,\r\n  3092502836, 388784114, 2624227202, 1425443689, 3057273783, 2347385850, 1682466193, 2519244187,\r\n  2839578677, 3958567839, 2513912981, 2830218821, 427810014\r\n]);\r\n", "import {IFCBUILDING, IfcContext} from 'web-ifc';\r\nimport {WebIfcAPI} from \"../../BaseDefinitions\";\r\nimport {IfcTypesMap} from \"../IfcTypesMap\";\r\nimport {geometryTypes} from \"./GeometryTypes\";\r\n\r\nexport class PropertySerializer {\r\n\r\n  dispose() {\r\n    (this.webIfc as any) = null;\r\n  }\r\n\r\n  constructor( private webIfc: WebIfcAPI) {\r\n  }\r\n\r\n  /**\r\n   * Serializes all the properties of an IFC (exluding the geometry) into an array of Blobs.\r\n   * This is useful for populating databases with IFC data.\r\n   * @modelID ID of the IFC model whose properties to extract.\r\n   * @maxSize (optional) maximum number of entities for each Blob. If not defined, it's infinite (only one Blob will be created).\r\n   * @event (optional) callback called every time a 10% of entities are serialized into Blobs.\r\n   */\r\n  async serializeAllProperties(\r\n    modelID: number,\r\n    maxSize?: number,\r\n    event?: (progress: number, total: number) => void\r\n  ) {\r\n    const blobs: Blob[] = [];\r\n    await this.getPropertiesAsBlobs(modelID, blobs, maxSize, event);\r\n    return blobs;\r\n  }\r\n\r\n  private async getPropertiesAsBlobs(\r\n    modelID: number,\r\n    blobs: Blob[],\r\n    maxSize?: number,\r\n    event?: (progress: number, total: number) => void\r\n  ) {\r\n    const geometriesIDs = await this.getAllGeometriesIDs(modelID);\r\n    let properties = await this.initializePropertiesObject(modelID);\r\n    const allLinesIDs = await this.webIfc!.GetAllLines(modelID);\r\n    const linesCount = allLinesIDs.size();\r\n    let lastEvent = 0.1;\r\n\r\n    let counter = 0;\r\n    for (let i = 0; i < linesCount; i++) {\r\n      const id = allLinesIDs.get(i);\r\n      if (!geometriesIDs.has(id)) {\r\n        // eslint-disable-next-line no-await-in-loop\r\n        await this.getItemProperty(modelID, id, properties);\r\n        counter++;\r\n      }\r\n      if (maxSize && counter > maxSize) {\r\n        blobs.push(new Blob([JSON.stringify(properties)], { type: 'application/json' }));\r\n        properties = {};\r\n        counter = 0;\r\n      }\r\n      if (event && i / linesCount > lastEvent) {\r\n        event(i, linesCount);\r\n        lastEvent += 0.1;\r\n      }\r\n    }\r\n\r\n    blobs.push(new Blob([JSON.stringify(properties)], { type: 'application/json' }));\r\n  }\r\n\r\n  private async getItemProperty(modelID: number, id: number, properties: any) {\r\n    try {\r\n      const props = await this.webIfc!.GetLine(modelID, id);\r\n      if (props.type) {\r\n        props.type = IfcTypesMap[props.type];\r\n      }\r\n      this.formatItemProperties(props);\r\n      properties[id] = props;\r\n    } catch (e) {\r\n      console.log(`There was a problem getting the properties of the item with ID ${id}`);\r\n    }\r\n  }\r\n\r\n  private formatItemProperties(props: any) {\r\n    Object.keys(props).forEach((key) => {\r\n      const value = props[key];\r\n      if (value && value.value !== undefined) props[key] = value.value;\r\n      else if (Array.isArray(value))\r\n        props[key] = value.map((item) => {\r\n          if (item && item.value) return item.value;\r\n          return item;\r\n        });\r\n    });\r\n  }\r\n\r\n  private async initializePropertiesObject(modelID: number): Promise<any> {\r\n    return {\r\n      coordinationMatrix: await this.webIfc!.GetCoordinationMatrix(modelID),\r\n      globalHeight: await this.getBuildingHeight(modelID)\r\n    };\r\n  }\r\n\r\n  private async getBuildingHeight(modelID: number) {\r\n    const building = await this.getBuilding(modelID);\r\n    let placement: any;\r\n    const siteReference = building.ObjectPlacement.PlacementRelTo;\r\n    if (siteReference) placement = siteReference.RelativePlacement.Location;\r\n    else placement = building.ObjectPlacement.RelativePlacement.Location;\r\n    const transform = placement.Coordinates.map((coord: any) => coord.value);\r\n    return transform[2];\r\n  }\r\n\r\n  private async getBuilding(modelID: number) {\r\n    const allBuildingsIDs = await this.webIfc.GetLineIDsWithType(modelID, IFCBUILDING);\r\n    const buildingID = allBuildingsIDs.get(0);\r\n    return this.webIfc.GetLine(modelID, buildingID, true);\r\n  }\r\n\r\n  private async getAllGeometriesIDs(modelID: number) {\r\n    const geometriesIDs = new Set<number>();\r\n    const geomTypesArray = Array.from(geometryTypes);\r\n    for (let i = 0; i < geomTypesArray.length; i++) {\r\n      const category = geomTypesArray[i];\r\n      // eslint-disable-next-line no-await-in-loop\r\n      const ids = await this.webIfc!.GetLineIDsWithType(modelID, category);\r\n      const idsSize = ids.size();\r\n      for (let j = 0; j < idsSize; j++) {\r\n        geometriesIDs.add(ids.get(j));\r\n      }\r\n    }\r\n    return geometriesIDs;\r\n  }\r\n}\r\n", "import {\r\n    IdAttrName\r\n} from '../../BaseDefinitions';\r\nimport { IfcState } from '../../BaseDefinitions';\r\nimport { BufferAttribute, BufferGeometry } from 'three';\r\nimport { WebIfcPropertyManager } from './WebIfcPropertyManager';\r\nimport { JSONPropertyManager } from './JSONPropertyManager';\r\nimport { PropertyManagerAPI, PropertyAPI } from './BaseDefinitions';\r\nimport {PropertySerializer} from \"./PropertySerializer\";\r\n\r\n/**\r\n * Contains the logic to get the properties of the items within an IFC model.\r\n */\r\nexport class PropertyManager implements PropertyManagerAPI {\r\n    serializer?: PropertySerializer;\r\n\r\n    private readonly webIfcProps: WebIfcPropertyManager;\r\n    private readonly jsonProps: JSONPropertyManager;\r\n    private currentProps: PropertyAPI;\r\n\r\n    constructor(private state: IfcState) {\r\n        this.webIfcProps = new WebIfcPropertyManager(state);\r\n        this.jsonProps = new JSONPropertyManager(state);\r\n        this.currentProps = this.webIfcProps;\r\n        this.serializer = new PropertySerializer(this.state.api);\r\n    }\r\n\r\n    getExpressId(geometry: BufferGeometry, faceIndex: number) {\r\n        if (!geometry.index) throw new Error('Geometry does not have index information.');\r\n        const geoIndex = geometry.index.array;\r\n        const bufferAttr = geometry.attributes[IdAttrName] as BufferAttribute;\r\n        return bufferAttr.getX(geoIndex[3 * faceIndex]);\r\n    }\r\n\r\n    async getItemProperties(modelID: number, elementID: number, recursive = false) {\r\n        this.updateCurrentProps();\r\n        return this.currentProps.getItemProperties(modelID, elementID, recursive);\r\n    }\r\n\r\n    async getAllItemsOfType(modelID: number, type: number, verbose: boolean) {\r\n        this.updateCurrentProps();\r\n        return this.currentProps.getAllItemsOfType(modelID, type, verbose);\r\n    }\r\n\r\n    async getPropertySets(modelID: number, elementID: number, recursive = false) {\r\n        this.updateCurrentProps();\r\n        return this.currentProps.getPropertySets(modelID, elementID, recursive);\r\n    }\r\n\r\n    async getTypeProperties(modelID: number, elementID: number, recursive = false) {\r\n        this.updateCurrentProps();\r\n        return this.currentProps.getTypeProperties(modelID, elementID, recursive);\r\n    }\r\n\r\n    async getMaterialsProperties(modelID: number, elementID: number, recursive = false) {\r\n        this.updateCurrentProps();\r\n        return this.currentProps.getMaterialsProperties(modelID, elementID, recursive);\r\n    }\r\n\r\n    async getSpatialStructure(modelID: number, includeProperties?: boolean) {\r\n        this.updateCurrentProps();\r\n        if (!this.state.useJSON && includeProperties) {\r\n            console.warn('Including properties in getSpatialStructure with the JSON workflow disabled can lead to poor performance.');\r\n        }\r\n        return await this.currentProps.getSpatialStructure(modelID, includeProperties);\r\n    }\r\n\r\n    private updateCurrentProps() {\r\n        this.currentProps = this.state.useJSON ? this.jsonProps : this.webIfcProps;\r\n    }\r\n\r\n}\r\n", "import { IfcState } from '../BaseDefinitions';\r\nimport { IfcElements } from './IFCElementsMap'\r\nimport { IFCWorkerHandler } from '../web-workers/IFCWorkerHandler';\r\n\r\n/**\r\n * Contains the logic to manage the type (e. g. IfcWall, IfcWindow, IfcDoor) of\r\n * all the items within an IFC file.\r\n */\r\nexport class TypeManager {\r\n\r\n    constructor(private state: IfcState) {\r\n        this.state = state;\r\n    }\r\n\r\n    async getAllTypes(worker?: IFCWorkerHandler){\r\n\t\tfor (let modelID in this.state.models) {\r\n\t\t\tif (this.state.models.hasOwnProperty(modelID)) {\r\n\t\t\t\tconst types = this.state.models[modelID].types;\r\n\t\t\t\tif (Object.keys(types).length == 0) {\r\n\t\t\t\t\tawait this.getAllTypesOfModel(parseInt(modelID), worker);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n    }\r\n\r\n    async getAllTypesOfModel(modelID: number, worker?: IFCWorkerHandler) {\r\n        const result = {};\r\n        const elements = Object.keys(IfcElements).map((e) => parseInt(e));\r\n        for(let i = 0; i < elements.length; i++) {\r\n            const element = elements[i];\r\n            const lines = await this.state.api.GetLineIDsWithType(modelID, element);\r\n            const size = lines.size();\r\n            //@ts-ignore\r\n            for (let i = 0; i < size; i++) result[lines.get(i)] = element;\r\n        }\r\n        if(this.state.worker.active && worker) {\r\n            // TODO: When using web workers, store the type information there and request it to the worker\r\n            // Otherwise the type data is stored in 2 different places at the same time\r\n            await worker.workerState.updateModelStateTypes(modelID, result);\r\n        }\r\n        this.state.models[modelID].types = result;\r\n    }\r\n}\r\n", "import { BufferGeometry, Mesh } from 'three';\r\n\r\nexport class BvhManager {\r\n    private computeBoundsTree?: any;\r\n    private disposeBoundsTree?: any;\r\n    private acceleratedRaycast?: any;\r\n\r\n    initializeMeshBVH(computeBoundsTree: any, disposeBoundsTree: any, acceleratedRaycast: any) {\r\n        this.computeBoundsTree = computeBoundsTree;\r\n        this.disposeBoundsTree = disposeBoundsTree;\r\n        this.acceleratedRaycast = acceleratedRaycast;\r\n        this.setupThreeMeshBVH();\r\n    }\r\n\r\n    applyThreeMeshBVH(geometry: BufferGeometry) {\r\n        if (this.computeBoundsTree)\r\n            //@ts-ignore\r\n            geometry.computeBoundsTree();\r\n    }\r\n\r\n    private setupThreeMeshBVH() {\r\n        if (!this.computeBoundsTree || !this.disposeBoundsTree || !this.acceleratedRaycast) return;\r\n        //@ts-ignore\r\n        BufferGeometry.prototype.computeBoundsTree = this.computeBoundsTree;\r\n        //@ts-ignore\r\n        BufferGeometry.prototype.disposeBoundsTree = this.disposeBoundsTree;\r\n        Mesh.prototype.raycast = this.acceleratedRaycast;\r\n    }\r\n}", "import { IfcState, WebIfcAPI } from '../BaseDefinitions';\r\n\r\nexport interface IfcWorkerAPI {\r\n    post: (data: any) => void;\r\n    initializeAPI: (api: WebIfcAPI) => void;\r\n    state?: IfcState;\r\n    postCallback: (data: any, result: any, serializer?: any) => void;\r\n}\r\n\r\nexport enum WorkerActions {\r\n    // Worker State Actions\r\n    updateStateUseJson = 'updateStateUseJson',\r\n    updateStateWebIfcSettings = 'updateStateWebIfcSettings',\r\n    updateModelStateTypes = 'updateModelStateTypes',\r\n    updateModelStateJsonData = 'updateModelStateJsonData',\r\n    loadJsonDataFromWorker = 'loadJsonDataFromWorker',\r\n    dispose = 'dispose',\r\n\r\n    // WebIFC Actions\r\n    Close = 'Close',\r\n    DisposeWebIfc = 'DisposeWebIfc',\r\n    Init = 'Init',\r\n    OpenModel = 'OpenModel',\r\n    CreateModel = 'CreateModel',\r\n    ExportFileAsIFC = 'ExportFileAsIFC',\r\n    GetGeometry = 'GetGeometry',\r\n    GetLine = 'GetLine',\r\n    GetAndClearErrors = 'GetAndClearErrors',\r\n    WriteLine = 'WriteLine',\r\n    FlattenLine = 'FlattenLine',\r\n    GetRawLineData = 'GetRawLineData',\r\n    WriteRawLineData = 'WriteRawLineData',\r\n    GetLineIDsWithType = 'GetLineIDsWithType',\r\n    GetAllLines = 'GetAllLines',\r\n    SetGeometryTransformation = 'SetGeometryTransformation',\r\n    GetCoordinationMatrix = 'GetCoordinationMatrix',\r\n    GetVertexArray = 'GetVertexArray',\r\n    GetIndexArray = 'GetIndexArray',\r\n    getSubArray = 'getSubArray',\r\n    CloseModel = 'CloseModel',\r\n    StreamAllMeshes = 'StreamAllMeshes',\r\n    StreamAllMeshesWithTypes = 'StreamAllMeshesWithTypes',\r\n    IsModelOpen = 'IsModelOpen',\r\n    LoadAllGeometry = 'LoadAllGeometry',\r\n    GetFlatMesh = 'GetFlatMesh',\r\n    SetWasmPath = 'SetWasmPath',\r\n\r\n    // Parser\r\n    parse = 'parse',\r\n    setupOptionalCategories = 'setupOptionalCategories',\r\n\r\n    // Properties\r\n    getExpressId = 'getExpressId',\r\n    initializeProperties = 'initializeProperties',\r\n    getAllItemsOfType = 'getAllItemsOfType',\r\n    getItemProperties = 'getItemProperties',\r\n    getMaterialsProperties = 'getMaterialsProperties',\r\n    getPropertySets = 'getPropertySets',\r\n    getSpatialStructure = 'getSpatialStructure',\r\n    getTypeProperties = 'getTypeProperties',    \r\n}\r\n\r\nexport enum WorkerAPIs {\r\n    workerState = 'workerState',\r\n    webIfc = 'webIfc',\r\n    properties = 'properties',\r\n    parser = 'parser',\r\n}\r\n\r\nexport interface IfcEventData {\r\n    worker: WorkerAPIs;\r\n    action: WorkerActions;\r\n    args: any;\r\n    id: number;\r\n    result: any;\r\n    onProgress: boolean;\r\n}\r\n\r\nexport interface RootWorker {\r\n    [WorkerAPIs.workerState]: WorkerStateAPI;\r\n    [WorkerAPIs.webIfc]: WebIfcWorkerAPI;\r\n    [WorkerAPIs.properties]: PropertyWorkerAPI;\r\n}\r\n\r\nexport interface BaseWorkerAPI {\r\n    API: WorkerAPIs;\r\n}\r\n\r\nexport type IfcWorkerEventHandler = (data: IfcEventData) => void;\r\n\r\nexport interface WorkerStateAPI extends BaseWorkerAPI {\r\n    [WorkerActions.updateStateUseJson]: IfcWorkerEventHandler;\r\n    [WorkerActions.updateStateWebIfcSettings]: IfcWorkerEventHandler;\r\n    [WorkerActions.updateModelStateTypes]: IfcWorkerEventHandler;\r\n    [WorkerActions.updateModelStateJsonData]: IfcWorkerEventHandler;\r\n    [WorkerActions.loadJsonDataFromWorker]: IfcWorkerEventHandler;\r\n    [WorkerActions.dispose]: IfcWorkerEventHandler;\r\n}\r\n\r\nexport interface PropertyWorkerAPI extends BaseWorkerAPI {\r\n    [WorkerActions.getAllItemsOfType]: IfcWorkerEventHandler;\r\n    [WorkerActions.getItemProperties]: IfcWorkerEventHandler;\r\n    [WorkerActions.getMaterialsProperties]: IfcWorkerEventHandler;\r\n    [WorkerActions.getPropertySets]: IfcWorkerEventHandler;\r\n    [WorkerActions.getSpatialStructure]: IfcWorkerEventHandler;\r\n    [WorkerActions.getTypeProperties]: IfcWorkerEventHandler;\r\n}\r\n\r\nexport interface ParserWorkerAPI extends BaseWorkerAPI {\r\n    [WorkerActions.parse]: IfcWorkerEventHandler;\r\n    [WorkerActions.setupOptionalCategories]: IfcWorkerEventHandler;\r\n}\r\n\r\nexport interface WebIfcWorkerAPI extends BaseWorkerAPI {\r\n    [WorkerActions.Init]: IfcWorkerEventHandler;\r\n    [WorkerActions.Close]: IfcWorkerEventHandler;\r\n    [WorkerActions.DisposeWebIfc]: IfcWorkerEventHandler;\r\n    [WorkerActions.OpenModel]: IfcWorkerEventHandler;\r\n    [WorkerActions.CreateModel]: IfcWorkerEventHandler;\r\n    [WorkerActions.ExportFileAsIFC]: IfcWorkerEventHandler;\r\n    [WorkerActions.GetGeometry]: IfcWorkerEventHandler;\r\n    [WorkerActions.GetLine]: IfcWorkerEventHandler;\r\n    [WorkerActions.GetAndClearErrors]: IfcWorkerEventHandler;\r\n    [WorkerActions.WriteLine]: IfcWorkerEventHandler;\r\n    [WorkerActions.FlattenLine]: IfcWorkerEventHandler;\r\n    [WorkerActions.GetRawLineData]: IfcWorkerEventHandler;\r\n    [WorkerActions.WriteRawLineData]: IfcWorkerEventHandler;\r\n    [WorkerActions.GetLineIDsWithType]: IfcWorkerEventHandler;\r\n    [WorkerActions.GetAllLines]: IfcWorkerEventHandler;\r\n    [WorkerActions.SetGeometryTransformation]: IfcWorkerEventHandler;\r\n    [WorkerActions.GetCoordinationMatrix]: IfcWorkerEventHandler;\r\n    [WorkerActions.GetVertexArray]: IfcWorkerEventHandler;\r\n    [WorkerActions.GetIndexArray]: IfcWorkerEventHandler;\r\n    [WorkerActions.getSubArray]: IfcWorkerEventHandler;\r\n    [WorkerActions.CloseModel]: IfcWorkerEventHandler;\r\n    [WorkerActions.StreamAllMeshes]: IfcWorkerEventHandler;\r\n    [WorkerActions.StreamAllMeshesWithTypes]: IfcWorkerEventHandler;\r\n    [WorkerActions.IsModelOpen]: IfcWorkerEventHandler;\r\n    [WorkerActions.LoadAllGeometry]: IfcWorkerEventHandler;\r\n    [WorkerActions.GetFlatMesh]: IfcWorkerEventHandler;\r\n    [WorkerActions.SetWasmPath]: IfcWorkerEventHandler;\r\n}\r\n\r\nexport interface SerializedVector {\r\n    [key: number]: any;\r\n\r\n    size: number;\r\n}\r\n\r\nexport interface SerializedIfcGeometry {\r\n    GetVertexData: number;\r\n    GetVertexDataSize: number;\r\n    GetIndexData: number;\r\n    GetIndexDataSize: number;\r\n}\r\n\r\nexport interface SerializedFlatMesh {\r\n    geometries: SerializedVector;\r\n    expressID: number;\r\n}\r\n\r\nexport const ErrorStateNotAvailable = 'The state of the worker does not exist';\r\nexport const ErrorRootStateNotAvailable = 'The root worker does not have any state';\r\nexport const ErrorPropertiesNotAvailable = 'Error: Properties not available from web worker';\r\nexport const ErrorParserNotAvailable = 'Error: Parser not available from web worker';\r\nexport const ErrorBadJsonPath = 'Error: Model not available from web worker';\r\nexport const ErrorBadJson = 'Error: The given Json could not be read as a JS object';", "import { SerializedVector } from '../BaseDefinitions';\r\nimport { Vector as WebIfcVector } from 'web-ifc';\r\n\r\nexport class Vector<T> implements WebIfcVector<T> {\r\n    private readonly _size: number;\r\n    private _data: { [key: number]: T } = {};\r\n\r\n    constructor(vector: SerializedVector) {\r\n        this._size = vector.size;\r\n        const keys = Object.keys(vector).filter((key) => key.indexOf('size') === -1).map(key => parseInt(key));\r\n        keys.forEach((key) => this._data[key] = vector[key]);\r\n    }\r\n\r\n    size() {\r\n        return this._size;\r\n    }\r\n\r\n    get(index: number) {\r\n        return this._data[index];\r\n    }\r\n}", "import { SerializedIfcGeometry } from '../BaseDefinitions';\r\nimport { IfcGeometry as WebIfcIfcGeometry } from 'web-ifc';\r\n\r\nexport class IfcGeometry implements WebIfcIfcGeometry {\r\n    private readonly _GetVertexData: number;\r\n    private readonly _GetVertexDataSize: number;\r\n    private readonly _GetIndexData: number;\r\n    private readonly _GetIndexDataSize: number;\r\n\r\n    constructor(vector: SerializedIfcGeometry) {\r\n        this._GetVertexData = vector.GetVertexData;\r\n        this._GetVertexDataSize = vector.GetVertexDataSize;\r\n        this._GetIndexData = vector.GetIndexData;\r\n        this._GetIndexDataSize = vector.GetIndexDataSize;\r\n    }\r\n\r\n    GetVertexData() {\r\n        return this._GetVertexData;\r\n    }\r\n\r\n    GetVertexDataSize() {\r\n        return this._GetVertexDataSize;\r\n    }\r\n\r\n    GetIndexData() {\r\n        return this._GetIndexData;\r\n    }\r\n\r\n    GetIndexDataSize() {\r\n        return this._GetIndexDataSize;\r\n    }\r\n}", "import { SerializedFlatMesh } from '../BaseDefinitions';\r\nimport { FlatMesh as WebIfcFlatMesh, PlacedGeometry } from 'web-ifc';\r\nimport { Vector } from './Vector';\r\nimport { Serializer } from './Serializer';\r\n\r\nexport class FlatMesh implements WebIfcFlatMesh {\r\n    geometries: Vector<PlacedGeometry>;\r\n    expressID: number;\r\n\r\n    constructor(serializer: Serializer, flatMesh: SerializedFlatMesh) {\r\n        this.expressID = flatMesh.expressID;\r\n        this.geometries = serializer.reconstructVector(flatMesh.geometries);\r\n    }\r\n}", "import { SerializedVector } from '../BaseDefinitions';\r\nimport { FlatMesh as WebIfcFlatMesh, Vector as WebIfcVector } from 'web-ifc';\r\nimport { Serializer } from './Serializer';\r\n\r\nexport class FlatMeshVector implements WebIfcVector<WebIfcFlatMesh> {\r\n    private readonly _size: number;\r\n    private _data: { [key: number]: WebIfcFlatMesh } = {};\r\n\r\n    constructor(serializer: Serializer, vector: SerializedVector) {\r\n        this._size = vector.size;\r\n        const keys = Object.keys(vector).filter((key) => key.indexOf('size') === -1).map(key => parseInt(key));\r\n        keys.forEach(key => this._data[key] = serializer.reconstructFlatMesh(vector[key]));\r\n    }\r\n\r\n    size() {\r\n        return this._size;\r\n    }\r\n\r\n    get(index: number) {\r\n        return this._data[index];\r\n    }\r\n}", "import {Color, DoubleSide, MeshLambertMaterial} from 'three';\r\n\r\nexport class SerializedMaterial {\r\n    color: number[];\r\n    opacity: number;\r\n    transparent: boolean;\r\n\r\n    constructor(material: MeshLambertMaterial) {\r\n        this.color = [material.color.r, material.color.g, material.color.b];\r\n        this.opacity = material.opacity;\r\n        this.transparent = material.transparent;\r\n    }\r\n}\r\n\r\nexport class MaterialReconstructor {\r\n    static new(material: SerializedMaterial) {\r\n        return new MeshLambertMaterial({\r\n            color: new Color(material.color[0], material.color[1], material.color[2]),\r\n            opacity: material.opacity,\r\n            transparent: material.transparent,\r\n            side: DoubleSide\r\n        })\r\n    }\r\n}", "import { BufferAttribute, BufferGeometry } from 'three';\r\n\r\nexport class SerializedGeometry {\r\n    position: ArrayLike<number>;\r\n    normal: ArrayLike<number>;\r\n    expressID: ArrayLike<number>;\r\n    index: ArrayLike<number>;\r\n    groups: { start: number, count: number, materialIndex?: number }[];\r\n\r\n    constructor(geometry: BufferGeometry) {\r\n        this.position = (geometry.attributes.position as BufferAttribute)?.array || [];\r\n        this.normal = (geometry.attributes.normal as BufferAttribute)?.array || [];\r\n        this.expressID = (geometry.attributes.expressID as BufferAttribute)?.array || [];\r\n        this.index = geometry.index?.array || [];\r\n        this.groups = geometry.groups;\r\n    }\r\n}\r\n\r\nexport class GeometryReconstructor {\r\n    static new(serialized: SerializedGeometry) {\r\n        const geom = new BufferGeometry();\r\n        GeometryReconstructor.set(geom, 'expressID', new Uint32Array(serialized.expressID), 1);\r\n        GeometryReconstructor.set(geom, 'position', new Float32Array(serialized.position), 3);\r\n        GeometryReconstructor.set(geom, 'normal', new Float32Array(serialized.normal), 3);\r\n        geom.setIndex(Array.from(serialized.index));\r\n        geom.groups = serialized.groups;\r\n        return geom;\r\n    }\r\n\r\n    private static set(geom: BufferGeometry, name: string, data: ArrayLike<number>, size: number) {\r\n        if(data.length > 0) {\r\n            geom.setAttribute(name, new BufferAttribute(data, size));\r\n        }\r\n    }\r\n}", "import { IFCModel } from '../../components/IFCModel';\r\nimport { Material, MeshLambertMaterial } from 'three';\r\nimport { MaterialReconstructor, SerializedMaterial } from './Material';\r\nimport { GeometryReconstructor, SerializedGeometry } from './Geometry';\r\n\r\nexport class SerializedMesh {\r\n\r\n    modelID: number;\r\n    geometry: SerializedGeometry;\r\n    materials: SerializedMaterial [] = [];\r\n\r\n    constructor(model: IFCModel) {\r\n        this.modelID = model.modelID;\r\n        this.geometry = new SerializedGeometry(model.geometry);\r\n        if (Array.isArray(model.material)) {\r\n            model.material.forEach(mat => {\r\n                this.materials.push(new SerializedMaterial(mat as MeshLambertMaterial));\r\n            });\r\n        } else {\r\n            this.materials.push(new SerializedMaterial(model.material as MeshLambertMaterial));\r\n        }\r\n    }\r\n}\r\n\r\nexport class MeshReconstructor {\r\n\r\n    static new(serialized: SerializedMesh) {\r\n        const model = new IFCModel();\r\n        model.modelID = serialized.modelID;\r\n        model.geometry = GeometryReconstructor.new(serialized.geometry);\r\n        MeshReconstructor.getMaterials(serialized, model);\r\n        return model;\r\n    }\r\n\r\n    private static getMaterials(serialized: SerializedMesh, model: IFCModel) {\r\n        model.material = [];\r\n        const mats = model.material as Material[];\r\n        serialized.materials.forEach(mat => {\r\n            mats.push(MaterialReconstructor.new(mat));\r\n        });\r\n    }\r\n}", "import { Vector as WebIfcVector, IfcGeometry as WebIfcIfcGeometry, FlatMesh as WebIfcFlatMesh } from 'web-ifc';\r\nimport { SerializedFlatMesh, SerializedIfcGeometry, SerializedVector } from '../BaseDefinitions';\r\nimport { Vector } from './Vector';\r\nimport { IfcGeometry } from './IfcGeometry';\r\nimport { FlatMesh } from './FlatMesh';\r\nimport { FlatMeshVector } from './FlatMeshVector';\r\nimport { IFCModel } from '../../components/IFCModel';\r\nimport { MeshReconstructor, SerializedMesh } from './Mesh';\r\n\r\nexport class Serializer {\r\n\r\n    serializeVector<T>(vector: WebIfcVector<T>) {\r\n        const size = vector.size();\r\n        const serialized: SerializedVector = { size };\r\n        for (let i = 0; i < size; i++) {\r\n            serialized[i] = vector.get(i);\r\n        }\r\n        return serialized;\r\n    }\r\n\r\n    reconstructVector(vector: SerializedVector): Vector<any> {\r\n        return new Vector(vector);\r\n    }\r\n\r\n    serializeIfcGeometry(geometry: WebIfcIfcGeometry) {\r\n        const GetVertexData = geometry.GetVertexData();\r\n        const GetVertexDataSize = geometry.GetVertexDataSize();\r\n        const GetIndexData = geometry.GetIndexData();\r\n        const GetIndexDataSize = geometry.GetIndexDataSize();\r\n        return {\r\n            GetVertexData,\r\n            GetVertexDataSize,\r\n            GetIndexData,\r\n            GetIndexDataSize\r\n        } as SerializedIfcGeometry;\r\n    }\r\n\r\n    reconstructIfcGeometry(geometry: SerializedIfcGeometry) {\r\n        return new IfcGeometry(geometry);\r\n    }\r\n\r\n    serializeFlatMesh(flatMesh: WebIfcFlatMesh) {\r\n        return {\r\n            expressID: flatMesh.expressID,\r\n            geometries: this.serializeVector(flatMesh.geometries)\r\n        } as SerializedFlatMesh;\r\n    }\r\n\r\n    reconstructFlatMesh(flatMesh: SerializedFlatMesh) {\r\n        return new FlatMesh(this, flatMesh);\r\n    }\r\n\r\n    serializeFlatMeshVector(vector: WebIfcVector<WebIfcFlatMesh>) {\r\n        const size = vector.size();\r\n        const serialized: SerializedVector = { size };\r\n        for (let i = 0; i < size; i++) {\r\n            const flatMesh = vector.get(i);\r\n            serialized[i] = this.serializeFlatMesh(flatMesh);\r\n        }\r\n        return serialized;\r\n    }\r\n\r\n    reconstructFlatMeshVector(vector: SerializedVector): WebIfcVector<WebIfcFlatMesh> {\r\n        return new FlatMeshVector(this, vector);\r\n    }\r\n\r\n    serializeIfcModel(model: IFCModel) {\r\n        return new SerializedMesh(model);\r\n    }\r\n\r\n    reconstructIfcModel(model: SerializedMesh) {\r\n        return MeshReconstructor.new(model);\r\n    }\r\n}", "import { PropertyManagerAPI } from '../../components/properties/BaseDefinitions';\r\nimport { IFCWorkerHandler } from '../IFCWorkerHandler';\r\nimport { WorkerActions, WorkerAPIs } from '../BaseDefinitions';\r\nimport { BufferAttribute, BufferGeometry } from 'three';\r\nimport { IdAttrName } from '../../BaseDefinitions';\r\n\r\nexport class PropertyHandler implements PropertyManagerAPI {\r\n\r\n    API = WorkerAPIs.properties;\r\n\r\n    constructor(private handler: IFCWorkerHandler) {\r\n    }\r\n\r\n    getExpressId(geometry: BufferGeometry, faceIndex: number) {\r\n        if (!geometry.index) throw new Error('Geometry does not have index information.');\r\n        const geoIndex = geometry.index.array;\r\n        const bufferAttr = geometry.attributes[IdAttrName] as BufferAttribute;\r\n        return bufferAttr.getX(geoIndex[3 * faceIndex]);\r\n    }\r\n\r\n    getAllItemsOfType(modelID: number, type: number, verbose: boolean): Promise<any[]> {\r\n        return this.handler.request(this.API, WorkerActions.getAllItemsOfType, { modelID, type, verbose });\r\n    }\r\n\r\n    getItemProperties(modelID: number, elementID: number, recursive: boolean): Promise<any> {\r\n        return this.handler.request(this.API, WorkerActions.getItemProperties, { modelID, elementID, recursive });\r\n    }\r\n\r\n    getMaterialsProperties(modelID: number, elementID: number, recursive: boolean): Promise<any[]> {\r\n        return this.handler.request(this.API, WorkerActions.getMaterialsProperties, { modelID, elementID, recursive });\r\n    }\r\n\r\n    getPropertySets(modelID: number, elementID: number, recursive: boolean): Promise<any[]> {\r\n        return this.handler.request(this.API, WorkerActions.getPropertySets, { modelID, elementID, recursive });\r\n    }\r\n\r\n    getTypeProperties(modelID: number, elementID: number, recursive: boolean): Promise<any[]> {\r\n        return this.handler.request(this.API, WorkerActions.getTypeProperties, { modelID, elementID, recursive });\r\n    }\r\n\r\n    getSpatialStructure(modelID: number, includeProperties?: boolean): Promise<any> {\r\n        return this.handler.request(this.API, WorkerActions.getSpatialStructure, { modelID, includeProperties });\r\n    }\r\n}", "import { WebIfcAPI } from '../../BaseDefinitions';\r\nimport {\r\n    SerializedFlatMesh,\r\n    SerializedIfcGeometry,\r\n    SerializedVector,\r\n    WorkerActions,\r\n    WorkerAPIs\r\n} from '../BaseDefinitions';\r\nimport { FlatMesh, IfcGeometry, LoaderError, LoaderSettings, RawLineData, Vector } from 'web-ifc';\r\nimport { IFCWorkerHandler } from '../IFCWorkerHandler';\r\nimport { Serializer } from '../serializer/Serializer';\r\n\r\nexport class WebIfcHandler implements WebIfcAPI {\r\n\r\n    wasmModule: any;\r\n    API = WorkerAPIs.webIfc;\r\n\r\n    constructor(private handler: IFCWorkerHandler, private serializer: Serializer) {\r\n    }\r\n\r\n    async Init(): Promise<void> {\r\n        this.wasmModule = true;\r\n        return this.handler.request(this.API, WorkerActions.Init);\r\n    }\r\n\r\n    async OpenModel(data: string | Uint8Array, settings?: LoaderSettings): Promise<number> {\r\n        return this.handler.request(this.API, WorkerActions.OpenModel, { data, settings });\r\n    }\r\n\r\n    async CreateModel(settings?: LoaderSettings): Promise<number> {\r\n        return this.handler.request(this.API, WorkerActions.CreateModel, { settings });\r\n    }\r\n\r\n    async ExportFileAsIFC(modelID: number): Promise<Uint8Array> {\r\n        return this.handler.request(this.API, WorkerActions.ExportFileAsIFC, { modelID });\r\n    }\r\n\r\n    async GetGeometry(modelID: number, geometryExpressID: number): Promise<IfcGeometry> {\r\n        this.handler.serializeHandlers[this.handler.requestID] = (geom: SerializedIfcGeometry) => {\r\n            return this.serializer.reconstructIfcGeometry(geom);\r\n        }\r\n        return this.handler.request(this.API, WorkerActions.GetGeometry, { modelID, geometryExpressID });\r\n    }\r\n\r\n    async GetLine(modelID: number, expressID: number, flatten?: boolean): Promise<any> {\r\n        return this.handler.request(this.API, WorkerActions.GetLine, { modelID, expressID, flatten });\r\n    }\r\n\r\n    async GetAndClearErrors(modelID: number): Promise<Vector<LoaderError>> {\r\n        this.handler.serializeHandlers[this.handler.requestID] = (vector: SerializedVector) => {\r\n            return this.serializer.reconstructVector(vector);\r\n        }\r\n        return this.handler.request(this.API, WorkerActions.GetAndClearErrors, { modelID });\r\n    }\r\n\r\n    async WriteLine(modelID: number, lineObject: any): Promise<void> {\r\n        return this.handler.request(this.API, WorkerActions.WriteLine, { modelID, lineObject });\r\n    }\r\n\r\n    async FlattenLine(modelID: number, line: any): Promise<void> {\r\n        return this.handler.request(this.API, WorkerActions.FlattenLine, { modelID, line });\r\n    }\r\n\r\n    async GetRawLineData(modelID: number, expressID: number): Promise<RawLineData> {\r\n        return this.handler.request(this.API, WorkerActions.GetRawLineData, { modelID, expressID });\r\n    }\r\n\r\n    async WriteRawLineData(modelID: number, data: RawLineData): Promise<any> {\r\n        return this.handler.request(this.API, WorkerActions.WriteRawLineData, { modelID, data });\r\n    }\r\n\r\n    async GetLineIDsWithType(modelID: number, type: number): Promise<Vector<number>> {\r\n        this.handler.serializeHandlers[this.handler.requestID] = (vector: SerializedVector) => {\r\n            return this.serializer.reconstructVector(vector);\r\n        }\r\n        return this.handler.request(this.API, WorkerActions.GetLineIDsWithType, { modelID, type });\r\n    }\r\n\r\n    async GetAllLines(modelID: number): Promise<Vector<number>> {\r\n        this.handler.serializeHandlers[this.handler.requestID] = (vector: SerializedVector) => {\r\n            return this.serializer.reconstructVector(vector);\r\n        }\r\n        return this.handler.request(this.API, WorkerActions.GetAllLines, { modelID });\r\n    }\r\n\r\n    async SetGeometryTransformation(modelID: number, transformationMatrix: number[]): Promise<void> {\r\n        return this.handler.request(this.API, WorkerActions.SetGeometryTransformation, {\r\n            modelID,\r\n            transformationMatrix\r\n        });\r\n    }\r\n\r\n    async GetCoordinationMatrix(modelID: number): Promise<number[]> {\r\n        return this.handler.request(this.API, WorkerActions.GetCoordinationMatrix, { modelID });\r\n    }\r\n\r\n    async GetVertexArray(ptr: number, size: number): Promise<Float32Array> {\r\n        return this.handler.request(this.API, WorkerActions.GetVertexArray, { ptr, size });\r\n    }\r\n\r\n    async GetIndexArray(ptr: number, size: number): Promise<Uint32Array> {\r\n        return this.handler.request(this.API, WorkerActions.GetIndexArray, { ptr, size });\r\n    }\r\n\r\n    async getSubArray(heap: any, startPtr: any, sizeBytes: any): Promise<any> {\r\n        return this.handler.request(this.API, WorkerActions.getSubArray, { heap, startPtr, sizeBytes });\r\n    }\r\n\r\n    async CloseModel(modelID: number): Promise<void> {\r\n        return this.handler.request(this.API, WorkerActions.CloseModel, { modelID });\r\n    }\r\n\r\n    async StreamAllMeshes(modelID: number, meshCallback: (mesh: FlatMesh) => void): Promise<void> {\r\n        this.handler.callbackHandlers[this.handler.requestID] = {\r\n            action: meshCallback,\r\n            serializer: this.serializer.reconstructFlatMesh\r\n        };\r\n        return this.handler.request(this.API, WorkerActions.StreamAllMeshes, { modelID });\r\n    }\r\n\r\n    async StreamAllMeshesWithTypes(modelID: number, types: number[], meshCallback: (mesh: FlatMesh) => void): Promise<void> {\r\n        this.handler.callbackHandlers[this.handler.requestID] = {\r\n            action: meshCallback,\r\n            serializer: this.serializer.reconstructFlatMesh\r\n        };\r\n        return this.handler.request(this.API, WorkerActions.StreamAllMeshesWithTypes, { modelID, types });\r\n    }\r\n\r\n    async IsModelOpen(modelID: number): Promise<boolean> {\r\n        return this.handler.request(this.API, WorkerActions.IsModelOpen, { modelID });\r\n    }\r\n\r\n    async LoadAllGeometry(modelID: number): Promise<Vector<FlatMesh>> {\r\n        this.handler.serializeHandlers[this.handler.requestID] = (vector: SerializedVector) => {\r\n            return this.serializer.reconstructFlatMeshVector(vector);\r\n        }\r\n        return this.handler.request(this.API, WorkerActions.LoadAllGeometry, { modelID });\r\n    }\r\n\r\n    async GetFlatMesh(modelID: number, expressID: number): Promise<FlatMesh> {\r\n        this.handler.serializeHandlers[this.handler.requestID] = (flatMesh: SerializedFlatMesh) => {\r\n            return this.serializer.reconstructFlatMesh(flatMesh);\r\n        }\r\n        return this.handler.request(this.API, WorkerActions.GetFlatMesh, { modelID, expressID });\r\n    }\r\n\r\n    async SetWasmPath(path: string): Promise<void> {\r\n        return this.handler.request(this.API, WorkerActions.SetWasmPath, { path });\r\n    }\r\n}", "import { WorkerActions, WorkerAPIs } from '../BaseDefinitions';\r\nimport { IFCWorkerHandler } from '../IFCWorkerHandler';\r\nimport { IfcState } from '../../BaseDefinitions';\r\n\r\nexport class WorkerStateHandler {\r\n    API = WorkerAPIs.workerState;\r\n    state: IfcState;\r\n\r\n    constructor(private handler: IFCWorkerHandler) {\r\n        this.state = this.handler.state;\r\n    }\r\n\r\n    async updateStateUseJson() {\r\n        const useJson = this.state.useJSON;\r\n        return this.handler.request(this.API, WorkerActions.updateStateUseJson, { useJson });\r\n    }\r\n\r\n    async updateStateWebIfcSettings() {\r\n        const webIfcSettings = this.state.webIfcSettings;\r\n        return this.handler.request(this.API, WorkerActions.updateStateWebIfcSettings, { webIfcSettings });\r\n    }\r\n\r\n    async updateModelStateTypes (modelID: number, types: any) {\r\n        return this.handler.request(this.API, WorkerActions.updateModelStateTypes, { modelID, types });\r\n    }\r\n\r\n    async updateModelStateJsonData(modelID: number, jsonData: any) {\r\n        return this.handler.request(this.API, WorkerActions.updateModelStateJsonData, { modelID, jsonData });\r\n    }\r\n\r\n    async loadJsonDataFromWorker(modelID: number, path: string) {\r\n        return this.handler.request(this.API, WorkerActions.loadJsonDataFromWorker, { modelID, path });\r\n    }\r\n}", "export enum DBOperation {\r\n    transferIfcModel,\r\n    transferIndividualItems\r\n}\r\n\r\nexport class IndexedDatabase {\r\n    async save(item: any, id: DBOperation) {\r\n        const open = IndexedDatabase.openOrCreateDB(id);\r\n        this.createSchema(open, id)\r\n        return new Promise<any>((resolve, reject) => {\r\n            open.onsuccess = () => this.saveItem(item, open, id, resolve);\r\n        });\r\n    }\r\n\r\n    async load(id: number) {\r\n        const open = IndexedDatabase.openOrCreateDB(id);\r\n        return new Promise<any>((resolve, reject) => {\r\n            open.onsuccess = () => this.loadItem(open, id, resolve);\r\n        })\r\n    }\r\n\r\n    private createSchema(open: IDBOpenDBRequest, id: DBOperation) {\r\n        open.onupgradeneeded = function () {\r\n            const db = open.result;\r\n            db.createObjectStore(id.toString(), {keyPath: \"id\"});\r\n        };\r\n    }\r\n\r\n    private saveItem(item: any, open: IDBOpenDBRequest, id: DBOperation, resolve: (value: any) => void ) {\r\n        const {db, tx, store} = IndexedDatabase.getDBItems(open, id);\r\n        item.id = id;\r\n        store.put(item);\r\n        tx.oncomplete = () => IndexedDatabase.closeDB(db, tx, resolve);\r\n    }\r\n\r\n    private loadItem(open: IDBOpenDBRequest, id: DBOperation, resolve: (value: any) => void ) {\r\n        const {db, tx, store} = IndexedDatabase.getDBItems(open, id);\r\n        const item = store.get(id);\r\n        const callback = () => {\r\n            delete item.result.id;\r\n            resolve(item.result)\r\n        };\r\n        tx.oncomplete = () => IndexedDatabase.closeDB(db, tx, callback);\r\n    }\r\n\r\n    private static getDBItems(open: IDBOpenDBRequest, id: DBOperation) {\r\n        const db = open.result;\r\n        const tx = db.transaction(id.toString(), \"readwrite\");\r\n        const store = tx.objectStore(id.toString());\r\n        return {db, tx, store};\r\n    }\r\n\r\n    private static openOrCreateDB(id: DBOperation) {\r\n        return indexedDB.open(id.toString(), 1);\r\n    }\r\n\r\n    private static closeDB(db: IDBDatabase, tx: IDBTransaction, resolve: (value: any) => void) {\r\n        db.close();\r\n        resolve(\"success\");\r\n    }\r\n}", "import {OptionalCategories, ParserAPI, ParserProgress } from '../../components/IFCParser';\r\nimport { WorkerActions, WorkerAPIs } from '../BaseDefinitions';\r\nimport { IFCWorkerHandler } from '../IFCWorkerHandler';\r\nimport { IFCModel } from '../../components/IFCModel';\r\nimport { Serializer } from '../serializer/Serializer';\r\nimport { ParserResult } from '../workers/ParserWorker';\r\nimport { BvhManager } from '../../components/BvhManager';\r\nimport { DBOperation, IndexedDatabase } from '../../indexedDB/IndexedDatabase';\r\nimport { IFCOPENINGELEMENT, IFCSPACE } from \"web-ifc\";\r\n\r\nexport class ParserHandler implements ParserAPI {\r\n\r\n    optionalCategories: OptionalCategories = {\r\n        [IFCSPACE]: true,\r\n        [IFCOPENINGELEMENT]: false\r\n    };\r\n\r\n    API = WorkerAPIs.parser;\r\n\r\n    constructor(private handler: IFCWorkerHandler,\r\n                private serializer: Serializer,\r\n                private BVH: BvhManager,\r\n                private IDB: IndexedDatabase) {\r\n    }\r\n\r\n    async setupOptionalCategories(config: OptionalCategories) {\r\n        this.optionalCategories = config;\r\n        return this.handler.request(this.API, WorkerActions.setupOptionalCategories, {config});\r\n    }\r\n\r\n    async parse(buffer: any, coordinationMatrix?: number[]): Promise<IFCModel> {\r\n        this.handler.onprogressHandlers[this.handler.requestID] = (progress: ParserProgress) => {\r\n            if (this.handler.state.onProgress) this.handler.state.onProgress(progress);\r\n        };\r\n        this.handler.serializeHandlers[this.handler.requestID] = async (result: ParserResult) => {\r\n            this.updateState(result.modelID);\r\n            // await this.getItems(result.modelID);\r\n            return this.getModel();\r\n        };\r\n        return this.handler.request(this.API, WorkerActions.parse, {buffer, coordinationMatrix});\r\n    }\r\n\r\n    getAndClearErrors(_modelId: number): void {\r\n    }\r\n\r\n    private updateState(modelID: number) {\r\n        this.handler.state.models[modelID] = {\r\n            modelID: modelID,\r\n            mesh: {} as any,\r\n            types: {},\r\n            jsonData: {}\r\n        };\r\n    }\r\n\r\n    // private async getItems(modelID: number) {\r\n    //     const items = await this.IDB.load(DBOperation.transferIndividualItems);\r\n    //     this.handler.state.models[modelID].items = this.serializer.reconstructGeometriesByMaterials(items);\r\n    // }\r\n\r\n    private async getModel() {\r\n        const serializedModel = await this.IDB.load(DBOperation.transferIfcModel);\r\n        const model = this.serializer.reconstructIfcModel(serializedModel);\r\n        this.BVH.applyThreeMeshBVH(model.geometry);\r\n        this.handler.state.models[model.modelID].mesh = model;\r\n        return model;\r\n    }\r\n}", "import { IfcEventData, WorkerActions, WorkerAPIs } from './BaseDefinitions';\r\nimport { Serializer } from './serializer/Serializer';\r\nimport { PropertyHandler } from './handlers/PropertyHandler';\r\nimport { WebIfcHandler } from './handlers/WebIfcHandler';\r\nimport { IfcState } from '../BaseDefinitions';\r\nimport { WorkerStateHandler } from './handlers/WorkerStateHandler';\r\nimport { ParserHandler } from './handlers/ParserHandler';\r\nimport { BvhManager } from '../components/BvhManager';\r\nimport { IndexedDatabase } from '../indexedDB/IndexedDatabase';\r\n\r\nexport class IFCWorkerHandler {\r\n\r\n    requestID = 0;\r\n    rejectHandlers: any = {};\r\n    resolveHandlers: any = {};\r\n    serializeHandlers: any = {};\r\n    callbackHandlers: { [id: number]: { action: any, serializer: any } } = {};\r\n    onprogressHandlers: any = {};\r\n\r\n    readonly IDB: IndexedDatabase;\r\n    readonly workerState: WorkerStateHandler;\r\n    readonly webIfc: WebIfcHandler;\r\n    readonly properties: PropertyHandler;\r\n    readonly parser: ParserHandler;\r\n\r\n    private ifcWorker: Worker;\r\n    private readonly serializer = new Serializer();\r\n    private readonly workerPath: string;\r\n\r\n    constructor(public state: IfcState, private BVH: BvhManager) {\r\n        this.IDB = new IndexedDatabase();\r\n        this.workerPath = this.state.worker.path;\r\n        this.ifcWorker = new Worker(this.workerPath);\r\n        this.ifcWorker.onmessage = (data: any) => this.handleResponse(data);\r\n        this.properties = new PropertyHandler(this);\r\n        this.parser = new ParserHandler(this, this.serializer, this.BVH, this.IDB);\r\n        this.webIfc = new WebIfcHandler(this, this.serializer);\r\n        this.workerState = new WorkerStateHandler(this);\r\n    }\r\n\r\n    request(worker: WorkerAPIs, action: WorkerActions, args?: any) {\r\n        const data: IfcEventData = {worker, action, args, id: this.requestID, result: undefined, onProgress: false};\r\n\r\n        return new Promise<any>((resolve, reject) => {\r\n            this.resolveHandlers[this.requestID] = resolve;\r\n            this.rejectHandlers[this.requestID] = reject;\r\n            this.requestID++;\r\n            this.ifcWorker.postMessage(data);\r\n        });\r\n    }\r\n\r\n    async terminate() {\r\n        await this.request(WorkerAPIs.workerState, WorkerActions.dispose);\r\n        await this.request(WorkerAPIs.webIfc, WorkerActions.DisposeWebIfc);\r\n        this.ifcWorker.terminate();\r\n    }\r\n\r\n    async Close(): Promise<void> {\r\n        await this.request(WorkerAPIs.webIfc, WorkerActions.Close);\r\n    }\r\n\r\n    private handleResponse(event: MessageEvent) {\r\n        const data = event.data as IfcEventData;\r\n        if (data.onProgress) {\r\n            this.resolveOnProgress(data);\r\n            return;\r\n        }\r\n        this.callHandlers(data);\r\n        delete this.resolveHandlers[data.id];\r\n        delete this.rejectHandlers[data.id];\r\n        delete this.onprogressHandlers[data.id];\r\n    }\r\n\r\n    private callHandlers(data: IfcEventData) {\r\n        try {\r\n            this.resolveSerializations(data);\r\n            this.resolveCallbacks(data);\r\n            this.resolveHandlers[data.id](data.result);\r\n        } catch (error) {\r\n            this.rejectHandlers[data.id](error);\r\n        }\r\n    }\r\n\r\n    private resolveOnProgress(data: IfcEventData) {\r\n        if (this.onprogressHandlers[data.id]) {\r\n            data.result = this.onprogressHandlers[data.id](data.result);\r\n        }\r\n    }\r\n\r\n    private resolveSerializations(data: IfcEventData) {\r\n        if (this.serializeHandlers[data.id]) {\r\n            data.result = this.serializeHandlers[data.id](data.result);\r\n            delete this.serializeHandlers[data.id];\r\n        }\r\n    }\r\n\r\n    private resolveCallbacks(data: IfcEventData) {\r\n        if (this.callbackHandlers[data.id]) {\r\n            let callbackParameter = data.result;\r\n            if (this.callbackHandlers[data.id].serializer) {\r\n                callbackParameter = this.callbackHandlers[data.id].serializer(data.result);\r\n            }\r\n            this.callbackHandlers[data.id].action(callbackParameter);\r\n        }\r\n    }\r\n}", "import { IfcState } from '../BaseDefinitions';\r\nimport { Material } from 'three';\r\n\r\nexport class MemoryCleaner {\r\n    constructor(private state: IfcState) {\r\n    }\r\n\r\n    async dispose() {\r\n\r\n        Object.keys(this.state.models).forEach(modelID => {\r\n            const model = this.state.models[parseInt(modelID, 10)];\r\n            model.mesh.removeFromParent();\r\n            const geom = model.mesh.geometry as any;\r\n            if (geom.disposeBoundsTree) geom.disposeBoundsTree();\r\n            geom.dispose();\r\n            if (!Array.isArray(model.mesh.material)) model.mesh.material.dispose();\r\n            else model.mesh.material.forEach(mat => mat.dispose());\r\n            (model.mesh as any) = null;\r\n            (model.types as any) = null;\r\n            (model.jsonData as any) = null;\r\n        });\r\n\r\n        (this.state.api as any) = null;\r\n        (this.state.models as any) = null;\r\n    }\r\n}", "import { IfcState } from '../BaseDefinitions';\r\nimport { IfcTypesMap } from './IfcTypesMap'\r\n\r\nexport class IFCUtils {\r\n    \r\n    map: {[key: string]: number} = {};\r\n\r\n    constructor(public state: IfcState) {}\r\n\r\n    getMapping(){\r\n        this.map = this.reverseElementMapping(IfcTypesMap)\r\n    }\r\n\r\n    releaseMapping(){\r\n        this.map = {}\r\n    }\r\n\r\n    reverseElementMapping(obj: {}) {\r\n        let reverseElement = {};\r\n        Object.keys(obj).forEach(key => {\r\n            reverseElement[obj[key as any as keyof typeof obj]] = key as any as keyof typeof obj;\r\n        })\r\n        return reverseElement;\r\n    }\r\n\r\n    isA(entity: any, entity_class: string){\r\n        var test = false;\r\n        if (entity_class){\r\n            if (IfcTypesMap[entity.type] === entity_class.toUpperCase()){\r\n                test = true;\r\n            }\r\n            return test\r\n        }\r\n        else {\r\n            return IfcTypesMap[entity.type]\r\n        }\r\n    }\r\n\r\n    async byId (modelID: number, id: number) {\r\n        return this.state.api.GetLine(modelID, id);\r\n    }\r\n\r\n    async idsByType(modelID: number, entity_class: string){\r\n        this.getMapping()\r\n        let entities_ids = await this.state.api.GetLineIDsWithType(modelID, Number(this.map[entity_class.toUpperCase()]) );\r\n        this.releaseMapping()\r\n        return entities_ids\r\n    }\r\n\r\n    async byType(modelID:number, entity_class:string){\r\n        let entities_ids = await this.idsByType(modelID, entity_class) \r\n        if (entities_ids !== null){\r\n            this.getMapping()\r\n            let items: number[] = [];\r\n            for (let i = 0; i < entities_ids.size(); i++){\r\n                let entity = await this.byId(modelID, entities_ids.get(i))\r\n                items.push(entity);\r\n            } \r\n            this.releaseMapping()\r\n            return items;\r\n        }\r\n    }\r\n}\r\n", "import { IfcState } from '../../BaseDefinitions';\r\nimport { IFCUtils } from '../IFCUtils'\r\n\r\nexport class Data {\r\n    isLoaded = false;\r\n    workPlans: {[key: number]: any} = {}\r\n    workSchedules: {[key: number]: any} = {}\r\n    workCalendars: {[key: number]: any} = {}\r\n    workTimes: {[key: number]: any} = {}\r\n    recurrencePatterns: {[key: number]: any} = {}\r\n    timePeriods: {[key: number]: any} = {}\r\n    tasks: {[key: number]: any} = {}\r\n    taskTimes: {[key: number]: any} = {}\r\n    lagTimes: {[key: number]: any} = {}\r\n    sequences: {[key: number]: any} = {}\r\n    utils: any;\r\n\r\n    constructor(public state: IfcState) {\r\n        this.utils = new IFCUtils(this.state);\r\n\r\n    }\r\n\r\n    //TO DO: Refactor to retrieve top-level task from a workschedule entity, and then load tasks.\r\n    // Currently only tasks are retrieved. \r\n    async load(modelID: number){\r\n        await this.loadTasks(modelID)\r\n        await this.loadWorkSchedules(modelID)\r\n        await this.loadWorkCalendars(modelID)\r\n        await this.loadWorkTimes(modelID)\r\n        await this.loadTimePeriods(modelID)\r\n        this.isLoaded = true\r\n\r\n    }\r\n\r\n\r\n    async loadWorkSchedules(modelID: number){\r\n        let workSchedules = await this.utils.byType(modelID, \"IfcWorkSchedule\")\r\n        for (let i = 0; i < workSchedules.length; i++){\r\n            let workSchedule = workSchedules[i]\r\n            this.workSchedules[workSchedule.expressID] = {   \r\n                \"Id\": workSchedule.expressID,\r\n                \"Name\": workSchedule.Name.value,\r\n                \"Description\": ((workSchedule.Description) ? workSchedule.Description.value : \"\"),\r\n                \"Creators\": [], \r\n                \"CreationDate\": ((workSchedule.CreationDate) ? workSchedule.CreationDate.value : \"\"),\r\n                \"StartTime\": ((workSchedule.StartTime) ? workSchedule.StartTime.value : \"\"),\r\n                \"FinishTime\": ((workSchedule.FinishTime) ? workSchedule.FinishTime.value : \"\"),\r\n                \"TotalFloat\": ((workSchedule.TotalFloat) ? workSchedule.TotalFloat.value : \"\"),\r\n                \"RelatedObjects\": [],\r\n            }\r\n        }\r\n        this.loadWorkScheduleRelatedObjects(modelID)\r\n    }\r\n\r\n\r\n    async loadWorkScheduleRelatedObjects(modelID: number){\r\n        let relsControls = await this.utils.byType(modelID, \"IfcRelAssignsToControl\");\r\n        for (let i = 0; i < relsControls.length; i++){\r\n            let relControls = relsControls[i];\r\n            let relatingControl = await this.utils.byId(modelID, relControls.RelatingControl.value);\r\n            let relatedObjects = relControls.RelatedObjects;\r\n            if (this.utils.isA(relatingControl, \"IfcWorkSchedule\")) {\r\n                for (var objectIndex = 0; objectIndex < relatedObjects.length; objectIndex++) {\r\n                    this.workSchedules[relatingControl.expressID][\"RelatedObjects\"].push(relatedObjects[objectIndex].value);\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    async loadTasks(modelID: number){\r\n        let tasks = await this.utils.byType(modelID, \"IfcTask\")\r\n        for (let i = 0; i < tasks.length; i++){\r\n            let task = tasks[i]\r\n            this.tasks[task.expressID] = {   \r\n                \"Id\": task.expressID,\r\n                \"Name\": ((task.Name) ? task.Name.value : \"\"),\r\n                \"PredefinedType\": ((task.PredefinedType) ? task.PredefinedType.value : \"\"),\r\n                \"TaskTime\": ((task.TaskTime) ? await this.utils.byId(modelID, task.TaskTime.value) : \"\"), \r\n                \"Identification\": ((task.Identification) ? task.Identification.value : \"\"),\r\n                \"IsMilestone\": ((task.IsMilestone) ? task.IsMilestone.value : \"\"),\r\n                \"IsPredecessorTo\": [],\r\n                \"IsSucessorFrom\": [],\r\n                \"Inputs\": [],\r\n                \"Resources\": [],\r\n                \"Outputs\": [],\r\n                \"Controls\": [],\r\n                \"Nests\": [],\r\n                \"IsNestedBy\": [],\r\n                \"OperatesOn\":[],\r\n                \"HasAssignmentsWorkCalendars\": [],\r\n            }\r\n        }\r\n        await this.loadTaskSequence(modelID)\r\n        await this.loadTaskOutputs(modelID)\r\n        await this.loadTaskNesting(modelID)\r\n        await this.loadTaskOperations(modelID)\r\n        await this.loadAssignementsWorkCalendar(modelID)\r\n    }\r\n\r\n    async loadTaskSequence(modelID: number){\r\n        let relsSequence = await this.utils.idsByType(modelID, \"IfcRelSequence\")\r\n        for (let i = 0; i < relsSequence.size(); i++){\r\n            let relSequenceId = relsSequence.get(i)\r\n            if(relSequenceId !==0){\r\n                let relSequence = await this.utils.byId(modelID, relSequenceId)\r\n                let related_process = relSequence.RelatedProcess.value;\r\n                let relatingProcess = relSequence.RelatingProcess.value;\r\n                this.tasks[relatingProcess][\"IsPredecessorTo\"].push(relSequence.expressID)\r\n                this.tasks[related_process][\"IsSucessorFrom\"].push(relSequence.expressID)\r\n            }\r\n        }\r\n            \r\n    }\r\n\r\n    async loadTaskOutputs(modelID: number){\r\n        let rels_assigns_to_product = await this.utils.byType(modelID, \"IfcRelAssignsToProduct\");\r\n        for (let i = 0; i < rels_assigns_to_product.length; i++){\r\n            let relAssignsToProduct = rels_assigns_to_product[i]\r\n            let relatedObject = await this.utils.byId(modelID, relAssignsToProduct.RelatedObjects[0].value); \r\n            if (this.utils.isA(relatedObject, \"IfcTask\")) {\r\n                let relatingProduct = await this.utils.byId(modelID, relAssignsToProduct.RelatingProduct.value);\r\n                this.tasks[relatedObject.expressID][\"Outputs\"].push(relatingProduct.expressID);\r\n            }\r\n        }\r\n    }\r\n\r\n    async loadTaskNesting(modelID: number){\r\n        let rels_nests = await this.utils.byType(modelID, \"IfcRelNests\");\r\n        for (let i = 0; i < rels_nests.length; i++){\r\n            let relNests = rels_nests[i];\r\n            let relating_object = await this.utils.byId(modelID, relNests.RelatingObject.value);\r\n            if (this.utils.isA(relating_object, \"IfcTask\")) {\r\n                let relatedObjects = relNests.RelatedObjects;\r\n                for (var object_index = 0; object_index < relatedObjects.length; object_index++) {\r\n                    this.tasks[relating_object.expressID][\"IsNestedBy\"].push(relatedObjects[object_index].value);\r\n                    this.tasks[relatedObjects[object_index].value][\"Nests\"].push(relating_object.expressID);\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    async loadTaskOperations(modelID: number){\r\n        let relsAssignsToProcess = await this.utils.byType(modelID, \"IfcRelAssignsToProcess\");\r\n        for (let i = 0; i < relsAssignsToProcess.length; i++){\r\n            let relAssignToProcess = relsAssignsToProcess[i];\r\n            let relatingProcess = await this.utils.byId(modelID, relAssignToProcess.RelatingProcess.value);\r\n            if (this.utils.isA(relatingProcess, \"IfcTask\")) {\r\n                let relatedObjects = relAssignToProcess.RelatedObjects;\r\n                for (var object_index = 0; object_index < relatedObjects.length; object_index++) {\r\n                    this.tasks[relatingProcess.expressID][\"OperatesOn\"].push(relatedObjects[object_index].value);\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    async loadAssignementsWorkCalendar(modelID: number){\r\n        let relsAssignsToControl = await this.utils.byType(modelID, \"IfcRelAssignsToControl\");\r\n        for (let i = 0; i < relsAssignsToControl.length; i++){\r\n            let relAssignsToControl = relsAssignsToControl[i];\r\n            let relatingControl = await this.utils.byId(modelID, relAssignsToControl.RelatingControl.value);\r\n            if (this.utils.isA(relatingControl, \"IfcWorkCalendar\")) {\r\n                let relatedObjects = relAssignsToControl.RelatedObjects;\r\n                for (var object_index = 0; object_index < relatedObjects.length; object_index++) {\r\n                    this.tasks[relatedObjects[object_index].value][\"HasAssignmentsWorkCalendars\"].push(relatingControl.expressID);\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    async loadWorkCalendars(modelID: number){\r\n        let workCalendars = await this.utils.byType(modelID, \"IfcWorkCalendar\")\r\n        for (let i = 0; i < workCalendars.length; i++){\r\n            let workCalendar = workCalendars[i]\r\n            let workCalenderData = {   \r\n                \"Id\": workCalendar.expressID,\r\n                \"Name\": ((workCalendar.Name) ? workCalendar.Name.value : \"\"),\r\n                \"Description\": ((workCalendar.Description) ? workCalendar.Description.value : \"\"),\r\n                \"WorkingTimes\": ((workCalendar.WorkingTimes) ? workCalendar.WorkingTimes : []),\r\n                \"ExceptionTimes\": ((workCalendar.ExceptionTimes) ? workCalendar.ExceptionTimes : []),\r\n            }\r\n            this.workCalendars[workCalendar.expressID] = workCalenderData\r\n        }\r\n        // this.loadworkCalendarRelatedObjects(modelID)\r\n    }    \r\n\r\n    async loadWorkTimes(modelID: number){\r\n        let workTimes = await this.utils.byType(modelID, \"IfcWorkTime\")\r\n        for (let i = 0; i < workTimes.length; i++){\r\n            let workTime = workTimes[i]\r\n            let workTimeData = {   \r\n                \"Name\": ((workTime.Name) ? workTime.Name.value : \"\"),\r\n                \"RecurrencePattern\": ((workTime.RecurrencePattern) ? await this.utils.byId(modelID, workTime.RecurrencePattern.value) : \"\"), \r\n                \"Start\": ((workTime.Start) ? new Date(workTime.Start.value) : \"\"),\r\n                \"Finish\": ((workTime.Finish) ? new Date(workTime.Finish.value) : \"\"),\r\n            }\r\n            this.workTimes[workTime.expressID] = workTimeData\r\n        }\r\n    }\r\n\r\n    async loadTimePeriods(modelID: number){\r\n        let timePeriods = await this.utils.byType(modelID, \"IfcTimePeriod\")\r\n        for (let i = 0; i < timePeriods.length; i++){\r\n            let timePeriod = timePeriods[i]\r\n            let workTimeData = {   \r\n                \"StartTime\": ((timePeriod.StartTime) ? new Date(timePeriod.StartTime.value) : \"\"),\r\n                \"EndTime\": ((timePeriod.EndTime) ? new Date(timePeriod.EndTime.value) : \"\"),\r\n            }\r\n            this.timePeriods[timePeriod.expressID] = workTimeData\r\n        }\r\n    }    \r\n}\r\n", "import * as WebIFC from 'web-ifc';\r\nimport { IFCParser, ParserAPI, ParserProgress } from './IFCParser';\r\nimport { SubsetManager } from './subsets/SubsetManager';\r\nimport { PropertyManager } from './properties/PropertyManager';\r\nimport { TypeManager } from './TypeManager';\r\nimport { SubsetConfig, IfcState, JSONObject } from '../BaseDefinitions';\r\nimport {BufferGeometry, Material, Matrix4, Scene} from 'three';\r\nimport { IFCModel } from './IFCModel';\r\nimport { BvhManager } from './BvhManager';\r\nimport { LoaderSettings } from 'web-ifc';\r\nimport { IFCWorkerHandler } from '../web-workers/IFCWorkerHandler';\r\nimport { PropertyManagerAPI } from './properties/BaseDefinitions';\r\nimport { MemoryCleaner } from './MemoryCleaner';\r\nimport { IFCUtils } from './IFCUtils';\r\nimport { Data } from './sequence/Data'\r\nimport { IfcTypesMap } from './IfcTypesMap';\r\n\r\n/**\r\n * Contains all the logic to work with the loaded IFC files (select, edit, etc).\r\n */\r\nexport class IFCManager {\r\n    state: IfcState = {\r\n        models: [],\r\n        api: new WebIFC.IfcAPI(),\r\n        useJSON: false,\r\n        worker: { active: false, path: '' }\r\n    };\r\n\r\n    BVH = new BvhManager();\r\n    parser: ParserAPI = new IFCParser(this.state, this.BVH);\r\n    subsets = new SubsetManager(this.state, this.BVH);\r\n    utils = new IFCUtils(this.state);\r\n    sequenceData = new Data(this.state);\r\n    properties: PropertyManagerAPI = new PropertyManager(this.state);\r\n    types = new TypeManager(this.state);\r\n\r\n    useFragments = false;\r\n\r\n    private cleaner = new MemoryCleaner(this.state);\r\n    private worker?: IFCWorkerHandler;\r\n\r\n    /**\r\n     * Returns the underlying web-ifc API.\r\n     */\r\n    get ifcAPI() {\r\n        return this.state.api;\r\n    }\r\n\r\n    // SETUP - all the logic regarding the configuration of web-ifc-three\r\n\r\n    async parse(buffer: ArrayBuffer) {\r\n        let model = await this.parser.parse(buffer, this.state.coordinationMatrix?.toArray()) as IFCModel;\r\n        model.setIFCManager(this);\r\n        // this.state.useJSON ? await this.disposeMemory() : await this.types.getAllTypes(this.worker);\r\n        await this.types.getAllTypes(this.worker);\r\n        return model;\r\n    }\r\n\r\n    /**\r\n     * Sets the relative path of web-ifc.wasm file in the project.\r\n     * Beware: you **must** serve this file in your page; this means\r\n     * that you have to copy this files from *node_modules/web-ifc*\r\n     * to your deployment directory.\r\n     *\r\n     * If you don't use this methods,\r\n     * IFC.js assumes that you are serving it in the root directory.\r\n     *\r\n     * Example if web-ifc.wasm is in dist/wasmDir:\r\n     * `ifcLoader.setWasmPath(\"dist/wasmDir/\");`\r\n     *\r\n     * @path Relative path to web-ifc.wasm.\r\n     */\r\n    async setWasmPath(path: string) {\r\n        this.state.api.SetWasmPath(path);\r\n        this.state.wasmPath = path;\r\n    }\r\n\r\n    /**\r\n     * Makes object picking a lot faster\r\n     * Courtesy of gkjohnson's [work](https://github.com/gkjohnson/three-mesh-bvh).\r\n     * Import these objects from his library and pass them as arguments. IFC.js takes care of the rest!\r\n     */\r\n    setupThreeMeshBVH(computeBoundsTree: any, disposeBoundsTree: any, acceleratedRaycast: any) {\r\n        this.BVH.initializeMeshBVH(computeBoundsTree, disposeBoundsTree, acceleratedRaycast);\r\n    }\r\n\r\n    /**\r\n     * Sets a callback function that is called every 10% of IFC loaded.\r\n     * @onProgress callback function\r\n     */\r\n    setOnProgress(onProgress: (event: ParserProgress) => void) {\r\n        this.state.onProgress = onProgress;\r\n    }\r\n\r\n\r\n    /**\r\n     * Sets a coordination matrix to be applied when loading geometry.\r\n     * @matrix THREE.Matrix4\r\n     */\r\n    setupCoordinationMatrix(matrix: Matrix4){\r\n        this.state.coordinationMatrix = matrix;\r\n    }\r\n\r\n    /**\r\n     * Clears the coordination matrix that is applied when loading geometry.\r\n     */\r\n    clearCoordinationMatrix(){\r\n        delete this.state.coordinationMatrix;\r\n    }\r\n\r\n    /**\r\n     * Applies a configuration for [web-ifc](https://ifcjs.github.io/info/docs/Guide/web-ifc/Introduction).\r\n     */\r\n    async applyWebIfcConfig(settings: LoaderSettings) {\r\n        this.state.webIfcSettings = settings;\r\n        if (this.state.worker.active && this.worker) {\r\n            await this.worker.workerState.updateStateWebIfcSettings();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Uses web workers, making the loader non-blocking.\r\n     * @active Wether to use web workers or not.\r\n     * @path Relative path to the web worker file. Necessary if active=true.\r\n     */\r\n    async useWebWorkers(active: boolean, path?: string) {\r\n        if (this.state.worker.active === active) return;\r\n        // @ts-ignore\r\n        this.state.api = null;\r\n        if (active) {\r\n            if (!path) throw new Error('You must provide a path to the web worker.');\r\n            this.state.worker.active = active;\r\n            this.state.worker.path = path;\r\n            await this.initializeWorkers();\r\n            const wasm = this.state.wasmPath;\r\n            if(wasm) await this.setWasmPath(wasm);\r\n        } else {\r\n            this.state.api = new WebIFC.IfcAPI();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @deprecated This approach had sense when the compute-heavy operations were blocking. If you are facing performance issues, you can either use webworkers or use the approach used in web-ifc-viewer to work with JSON and glTF. If you have any question regarding this, check out the docs or ask us direclty.\r\n     * Enables the JSON mode (which consumes way less memory) and eliminates the WASM data.\r\n     * Only use this in the following scenarios:\r\n     * - If you don't need to access the properties of the IFC\r\n     * - If you will provide the properties as JSON.\r\n     * @useJSON: Wether to use the JSON mode or not.\r\n     */\r\n    async useJSONData(useJSON = true) {\r\n        this.state.useJSON = useJSON;\r\n        if (useJSON) {\r\n            await this.worker?.workerState.updateStateUseJson();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @deprecated This approach had sense when the compute-heavy operations were blocking. If you are facing performance issues, you can either use webworkers or use the approach used in web-ifc-viewer to work with JSON and glTF. If you have any question regarding this, check out the docs or ask us direclty.\r\n     * Adds the properties of a model as JSON data. If you are using web workers, use\r\n     * `loadJsonDataFromWorker()` instead to avoid overheads.\r\n     * @modelID ID of the IFC model.\r\n     * @data: data as an object where the keys are the expressIDs and the values the properties.\r\n     */\r\n    async addModelJSONData(modelID: number, data: { [id: number]: JSONObject }) {\r\n        const model = this.state.models[modelID];\r\n        if (!model) throw new Error('The specified model for the JSON data does not exist');\r\n        if (this.state.worker.active) {\r\n            await this.worker?.workerState.updateModelStateJsonData(modelID, data);\r\n        } else {\r\n            model.jsonData = data;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @deprecated This approach had sense when the compute-heavy operations were blocking. If you are facing performance issues, you can either use webworkers or use the approach used in web-ifc-viewer to work with JSON and glTF. If you have any question regarding this, check out the docs or ask us direclty.\r\n     * Loads the data of an IFC model from a JSON file directly from a web worker. If you are not using\r\n     * web workers, use `addModelJSONData()` instead.\r\n     * @modelID ID of the IFC model.\r\n     * @path: the path to the JSON file **relative to the web worker file**.\r\n     */\r\n    async loadJsonDataFromWorker(modelID: number, path: string) {\r\n        if (this.state.worker.active) {\r\n            await this.worker?.workerState.loadJsonDataFromWorker(modelID, path);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Closes the specified model and deletes it from the [scene](https://threejs.org/docs/#api/en/scenes/Scene).\r\n     * @modelID ID of the IFC model.\r\n     * @scene Scene where the model is (if it's located in a scene).\r\n     */\r\n    close(modelID: number, scene?: Scene) {\r\n        try {\r\n            this.state.api.CloseModel(modelID);\r\n            const mesh = this.state.models[modelID].mesh;\r\n            const { geometry, material } = mesh;\r\n            if (scene) scene.remove(mesh);\r\n            geometry?.dispose();\r\n            Array.isArray(material) ? material.forEach(m => m.dispose()) : material?.dispose();\r\n            delete this.state.models[modelID];\r\n        } catch(e) {\r\n            console.warn(`Close IFCModel ${modelID} failed`);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets the **Express ID** to which the given face belongs.\r\n     * This ID uniquely identifies this entity within this IFC file.\r\n     * @geometry The geometry IFC model.\r\n     * @faceIndex The index of the face of a geometry.You can easily get this index using the [Raycaster](https://threejs.org/docs/#api/en/core/Raycaster).\r\n     */\r\n    getExpressId(geometry: BufferGeometry, faceIndex: number) {\r\n        return this.properties.getExpressId(geometry, faceIndex);\r\n    }\r\n\r\n    /**\r\n     * Returns all items of the specified type. You can import\r\n     * the types from *web-ifc*.\r\n     *\r\n     * Example to get all the standard walls of a project:\r\n     * ```js\r\n     * import { IFCWALLSTANDARDCASE } from 'web-ifc';\r\n     * const walls = ifcLoader.getAllItemsOfType(IFCWALLSTANDARDCASE);\r\n     * ```\r\n     * @modelID ID of the IFC model.\r\n     * @type type of IFC items to get.\r\n     * @verbose If false (default), this only gets IDs. If true, this also gets the native properties of all the fetched items.\r\n     */\r\n    getAllItemsOfType(modelID: number, type: number, verbose: boolean) {\r\n        return this.properties.getAllItemsOfType(modelID, type, verbose);\r\n    }\r\n\r\n    /**\r\n     * Gets the native properties of the given element.\r\n     * @modelID ID of the IFC model.\r\n     * @id Express ID of the element.\r\n     * @recursive Wether you want to get the information of the referenced elements recursively.\r\n     */\r\n    getItemProperties(modelID: number, id: number, recursive = false) {\r\n        return this.properties.getItemProperties(modelID, id, recursive);\r\n    }\r\n\r\n    /**\r\n     * Gets the [property sets](https://standards.buildingsmart.org/IFC/DEV/IFC4_2/FINAL/HTML/schema/ifckernel/lexical/ifcpropertyset.htm)\r\n     * assigned to the given element.\r\n     * @modelID ID of the IFC model.\r\n     * @id Express ID of the element.\r\n     * @recursive If true, this gets the native properties of the referenced elements recursively.\r\n     */\r\n    getPropertySets(modelID: number, id: number, recursive = false) {\r\n        return this.properties.getPropertySets(modelID, id, recursive);\r\n    }\r\n\r\n    /**\r\n     * Gets the properties of the type assigned to the element.\r\n     * For example, if applied to a wall (IfcWall), this would get back the information\r\n     * contained in the IfcWallType assigned to it, if any.\r\n     * @modelID ID of the IFC model.\r\n     * @id Express ID of the element.\r\n     * @recursive If true, this gets the native properties of the referenced elements recursively.\r\n     */\r\n    getTypeProperties(modelID: number, id: number, recursive = false) {\r\n        return this.properties.getTypeProperties(modelID, id, recursive);\r\n    }\r\n\r\n    /**\r\n     * Gets the materials assigned to the given element.\r\n     * @modelID ID of the IFC model.\r\n     * @id Express ID of the element.\r\n     * @recursive If true, this gets the native properties of the referenced elements recursively.\r\n     */\r\n    getMaterialsProperties(modelID: number, id: number, recursive = false) {\r\n        return this.properties.getMaterialsProperties(modelID, id, recursive);\r\n    }\r\n\r\n    /**\r\n     * Gets the ifc type of the specified item.\r\n     * @modelID ID of the IFC model.\r\n     * @id Express ID of the element.\r\n     */\r\n    getIfcType(modelID: number, id: number) {\r\n        const typeID = this.state.models[modelID].types[id];\r\n        return IfcTypesMap[typeID];\r\n    }\r\n\r\n    /**\r\n     * Gets the spatial structure of the project. The\r\n     * [spatial structure](https://standards.buildingsmart.org/IFC/DEV/IFC4_2/FINAL/HTML/schema/ifcproductextension/lexical/ifcspatialstructureelement.htm)\r\n     * is the hierarchical structure that organizes every IFC project (all physical items\r\n     * are referenced to an element of the spatial structure). It is formed by\r\n     * one IfcProject that contains one or more IfcSites, that contain one or more\r\n     * IfcBuildings, that contain one or more IfcBuildingStoreys, that contain\r\n     * one or more IfcSpaces.\r\n     * @modelID ID of the IFC model.\r\n     */\r\n    getSpatialStructure(modelID: number, includeProperties?: boolean) {\r\n        return this.properties.getSpatialStructure(modelID, includeProperties);\r\n    }\r\n\r\n    /**\r\n     * Gets the mesh of the subset with the specified [material](https://threejs.org/docs/#api/en/materials/Material).\r\n     * If no material is given, this returns the subset with the original materials.\r\n     * @modelID ID of the IFC model.\r\n     * @material Material assigned to the subset (if any).\r\n     * @customId Optional identifier of the subset.\r\n     */\r\n    getSubset(modelID: number, material?: Material, customId?: string) {\r\n        return this.subsets.getSubset(modelID, material, customId);\r\n    }\r\n\r\n    /**\r\n     * Removes the specified subset.\r\n     * @modelID ID of the IFC model.\r\n     * @parent The parent where the subset is (can be any `THREE.Object3D`).\r\n     * @material Material assigned to the subset, if any.\r\n     */\r\n    removeSubset(modelID: number, material?: Material, customID?: string) {\r\n        this.subsets.removeSubset(modelID, material, customID);\r\n    }\r\n\r\n    /**\r\n     * Creates a new geometric subset.\r\n     * @config A configuration object with the following options:\r\n     * - **scene**: `THREE.Object3D` where the model is located.\r\n     * - **modelID**: ID of the model.\r\n     * - **ids**: Express IDs of the items of the model that will conform the subset.\r\n     * - **removePrevious**: wether to remove the previous subset of this model with this material.\r\n     * - **material**: (optional) wether to apply a material to the subset.\r\n     * - **customID**: (optional) custom identifier to distinguish subsets of the same model with the same material.\r\n     */\r\n    createSubset(config: SubsetConfig) {\r\n        return this.subsets.createSubset(config);\r\n    }\r\n\r\n    /**\r\n     * Removes the specified items from the geometry of a subset.\r\n     * @modelID ID of the IFC model.\r\n     * @ids Express IDs of the items of the model that will conform the subset.\r\n     * @material (optional) Material assigned to the subset, if any.\r\n     * @customID (optional) custom identifier to distinguish subsets of the same model with the same material.\r\n     */\r\n    removeFromSubset(modelID: number, ids: number[], customID?: string, material?: Material) {\r\n        return this.subsets.removeFromSubset(modelID, ids, customID, material);\r\n    }\r\n\r\n    /**\r\n     * Removes all the geometry of a subset.\r\n     * @modelID ID of the IFC model.\r\n     * @ids Express IDs of the items of the model that will conform the subset.\r\n     * @material (optional) Material assigned to the subset, if any.\r\n     * @customID (optional) custom identifier to distinguish subsets of the same model with the same material.\r\n     */\r\n    clearSubset(modelID: number, customID?: string, material?: Material) {\r\n        return this.subsets.clearSubset(modelID, customID, material);\r\n    }\r\n\r\n\r\n\r\n\r\n    // UTILITIES - Miscelaneus logic for various purposes\r\n\r\n    /**\r\n    * Returns the IFC class name of an instance if the optional parameter is not provided.\r\n    * If an entit class is provided, it will check if an instance belongs to the class.\r\n    * @modelID ID of the IFC model.\r\n    * @entityClass IFC Class name.\r\n    */\r\n    async isA(entity: any, entity_class: string) {\r\n        return this.utils.isA(entity, entity_class);\r\n    }\r\n\r\n    async getSequenceData(modelID: number) {\r\n        await this.sequenceData.load(modelID);\r\n        return this.sequenceData;\r\n    }\r\n\r\n\r\n    /**\r\n    * Returns the IFC objects filtered by IFC Type and wrapped with the entity_instance class.\r\n    * If an IFC type class has subclasses, all entities of those subclasses are also returned.\r\n    * @modelID ID of the IFC model.\r\n    * @entityClass IFC Class name.\r\n    */\r\n    async byType(modelID: number, entityClass: string) {\r\n        return this.utils.byType(modelID, entityClass);\r\n    }\r\n\r\n    /**\r\n    * Returns the IFC objects filtered by IFC ID.\r\n    * @modelID ID of the IFC model.\r\n    * @id Express ID of the element.\r\n    */\r\n    async byId(modelID: number, id: number) {\r\n        return this.utils.byId(modelID, id);\r\n    }\r\n\r\n    /**\r\n    * Returns the IFC objects filtered by IFC Type and wrapped with the entity_instance class.\r\n    * If an IFC type class has subclasses, all entities of those subclasses are also returned.\r\n    * @modelID ID of the IFC model.\r\n    * @entityClass IFC Class name.\r\n    */\r\n    async idsByType(modelID: number, entityClass: string) {\r\n        return this.utils.idsByType(modelID, entityClass);\r\n    }\r\n\r\n\r\n    // MISC - Miscelaneus logic for various purposes\r\n\r\n    /**\r\n     * Disposes all memory used by the IFCLoader, including WASM memory and the web worker.\r\n     * Use this if you want to destroy the object completely.\r\n     * If you want to load an IFC later, you'll need to create a new instance.\r\n     */\r\n    async dispose() {\r\n        IFCModel.dispose();\r\n        await this.cleaner.dispose();\r\n        this.subsets.dispose();\r\n        if(this.worker && this.state.worker.active) await this.worker.terminate();\r\n        (this.state as any) = null;\r\n    }\r\n\r\n    /**\r\n     * @deprecated This approach had sense when the compute-heavy operations were blocking. If you are facing performance issues, you can either use webworkers or use the approach used in web-ifc-viewer to work with JSON and glTF. If you have any question regarding this, check out the docs or ask us direclty.\r\n     * Completely releases the WASM memory, thus drastically decreasing the memory use of the app.\r\n     * Only use this in the following scenarios:\r\n     * - If you don't need to access the properties of the IFC\r\n     * - If you will provide the properties as JSON.\r\n     */\r\n    async disposeMemory() {\r\n        if (this.state.worker.active) {\r\n            await this.worker?.Close();\r\n        } else {\r\n            // @ts-ignore\r\n            this.state.api.Close();\r\n            (this.state.api as any) = null;\r\n            this.state.api = new WebIFC.IfcAPI();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * For internal use of IFC.js dev team and testers\r\n     */\r\n    getAndClearErrors(modelID: number) {\r\n        return this.parser.getAndClearErrors(modelID);\r\n    }\r\n\r\n    private async initializeWorkers() {\r\n        this.worker = new IFCWorkerHandler(this.state, this.BVH);\r\n        this.state.api = this.worker.webIfc;\r\n        this.properties = this.worker.properties;\r\n        await this.worker.parser.setupOptionalCategories(this.parser.optionalCategories);\r\n        this.parser = this.worker.parser;\r\n        await this.worker.workerState.updateStateUseJson();\r\n        await this.worker.workerState.updateStateWebIfcSettings();\r\n    }\r\n\r\n\r\n}\r\n", "import { IFCManager } from './IFC/components/IFCManager';\r\nimport {FileLoader, Loader, LoadingManager, Matrix4} from 'three';\r\nimport { IFCModel } from './IFC/components/IFCModel';\r\n\r\nclass IFCLoader extends Loader {\r\n    ifcManager: IFCManager;\r\n    private onProgress?: (event: ProgressEvent) => void;\r\n\r\n    constructor(manager?: LoadingManager) {\r\n        super(manager);\r\n        this.ifcManager = new IFCManager();\r\n    }\r\n\r\n    load(\r\n        url: any,\r\n        onLoad: (ifc: IFCModel) => void,\r\n        onProgress?: (event: ProgressEvent) => void,\r\n        onError?: (event: ErrorEvent) => void\r\n    ) {\r\n        const scope = this;\r\n\r\n        const loader = new FileLoader(scope.manager);\r\n        this.onProgress = onProgress;\r\n        loader.setPath(scope.path);\r\n        loader.setResponseType('arraybuffer');\r\n        loader.setRequestHeader(scope.requestHeader);\r\n        loader.setWithCredentials(scope.withCredentials);\r\n        loader.load(\r\n            url,\r\n            async function (buffer) {\r\n                try {\r\n                    if (typeof buffer == 'string') {\r\n                        throw new Error('IFC files must be given as a buffer!');\r\n                    }\r\n                    onLoad(await scope.parse(buffer));\r\n                } catch (e: any) {\r\n                    if (onError) {\r\n                        onError(e);\r\n                    } else {\r\n                        console.error(e);\r\n                    }\r\n\r\n                    scope.manager.itemError(url);\r\n                }\r\n            },\r\n            onProgress,\r\n            onError\r\n        );\r\n    }\r\n\r\n    parse(buffer: ArrayBuffer) {\r\n        return this.ifcManager.parse(buffer);\r\n    }\r\n}\r\n\r\nexport { IFCLoader };\r\n"],
  "mappings": "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,YAAS;EACT,YAAU;EACV,YAAU;EACV,WAAS;EACT,YAAS;EACT,YAAS;EACT,YAAU;EACV,YAAS;EACT,YAAU;EACV,YAAU;EACV,WAAA;EACA,WAAQ;EACR,YAAU;EACV,YAAU;EACV,YAAU;EACV,YAAU;EACV,YAAU;EACV,UAAA;EACA,YAAU;EACV,YAAS;EACT,YAAU;EACV,WAAA;EACA,WAAQ;EACR,WAAA;EACA,WAAA;EACA,YAAS;EACT,YAAU;EACV,YAAU;EACV,YAAU;EACV,YAAU;EACV,YAAU;EACV,WAAS;EACT,YAAU;EACV,YAAU;EACV,YAAU;EACV,YAAU;EACV,YAAU;EACV,YAAU;EACV,YAAU;EACV,WAAS;EACT,WAAA;EACA,YAAU;EACV,WAAA;EACA,YAAS;EACT,YAAU;EACV,WAAA;EACA,YAAU;EACV,UAAA;EACA,WAAA;EACA,YAAU;EACV,YAAS;EACT,YAAU;EACV,YAAU;EACV,YAAU;EACV,YAAU;EACV,YAAU;EACV,YAAU;EACV,YAAS;EACT,YAAU;EACV,YAAU;EACV,YAAU;EACV,WAAA;EACA,WAAA;EACA,YAAU;EACV,YAAU;EACV,YAAU;EACV,UAAA;EACA,YAAU;EACV,YAAU;EACV,YAAU;EACV,YAAU;EACV,YAAU;EACV,YAAU;EACV,YAAU;EACV,YAAU;EACV,WAAA;EACA,WAAA;EACA,YAAU;EACV,YAAU;EACV,YAAU;EACV,YAAU;EACV,YAAU;EACV,YAAU;EACV,YAAS;EACT,YAAU;EACV,YAAU;EACV,WAAA;EACA,YAAU;EACV,YAAU;EACV,UAAA;EACA,YAAU;EACV,YAAU;EACV,YAAU;EACV,YAAS;EACT,YAAU;EACV,YAAS;EACT,YAAU;EACV,YAAU;EACV,YAAU;EACV,YAAS;EACT,YAAU;EACV,YAAS;EACT,YAAU;EACV,YAAS;EACT,YAAS;EACT,WAAA;EACA,WAAA;EACA,YAAU;EACV,WAAA;EACA,YAAU;EACV,WAAS;EACT,YAAU;EACV,YAAU;EACV,WAAS;EACT,WAAS;EACT,WAAA;EACA,YAAU;EACV,WAAA;EACA,YAAS;EACT,YAAU;EACV,YAAS;EACT,UAAA;EACA,YAAU;EACV,YAAS;EACT,YAAU;EACV,YAAU;EACV,YAAU;EACV,YAAU;EACV,YAAU;EACV,WAAA;EACA,YAAS;EACT,YAAU;EACV,UAAA;EACA,YAAU;EACV,YAAU;EACV,WAAA;EACA,YAAU;EACV,YAAS;EACT,YAAU;EACV,YAAU;EACV,YAAS;EACT,WAAA;EACA,YAAU;EACV,YAAS;EACT,YAAU;EACV,YAAS;EACT,YAAU;EACV,YAAU;EACV,UAAA;EACA,WAAA;EACA,YAAU;EACV,YAAU;EACV,YAAU;EACV,WAAA;EACA,YAAS;EACT,YAAU;EACV,YAAU;EACV,YAAU;EACV,YAAU;EACV,YAAS;EACT,WAAA;EACA,YAAS;EACT,YAAU;EACV,YAAU;EACV,YAAU;EACV,YAAU;EACV,YAAU;EACV,WAAS;EACT,YAAS;EACT,YAAU;EACV,YAAU;EACV,YAAU;EACV,YAAU;EACV,YAAS;EACT,YAAS;EACT,YAAS;EACT,YAAS;EACT,YAAU;EACV,YAAU;EACV,YAAU;EACV,YAAU;EACV,YAAU;EACV,YAAU;EACV,YAAU;EACV,YAAU;EACV,YAAS;EACT,YAAU;EACV,UAAA;EACA,YAAU;EACV,YAAU;EACV,YAAU;EACV,YAAS;EACT,YAAU;EACV,WAAS;EACT,YAAU;EACV,YAAU;EACV,YAAU;EACV,YAAU;EACV,YAAU;EACV,YAAS;EACT,YAAU;EACV,YAAS;EACT,YAAU;EACV,WAAA;EACA,YAAU;EACV,WAAA;EACA,YAAU;EACV,YAAS;EACT,YAAU;EACV,WAAA;EACA,YAAU;EACV,WAAA;EACA,YAAU;EACV,WAAS;EACT,WAAS;EACT,YAAU;EACV,YAAS;EACT,YAAU;EACV,YAAU;EACV,YAAU;EACV,WAAA;EACA,YAAU;EACV,YAAU;EACV,WAAA;EACA,WAAA;EACA,YAAS;EACT,YAAU;EACV,YAAU;EACV,WAAA;EACA,YAAU;EACV,WAAA;EACA,YAAU;EACV,YAAU;EACV,WAAA;EACA,YAAU;EACV,YAAU;EACV,YAAU;EACV,YAAS;EACT,YAAU;EACV,YAAS;EACT,WAAA;EACA,YAAU;EACV,YAAU;EACV,YAAU;EACV,YAAU;EACV,YAAU;EACV,YAAS;EACT,WAAA;EACA,YAAU;EACV,YAAU;EACV,WAAS;EACT,YAAU;EACV,YAAU;EACV,WAAA;EACA,YAAU;EACV,WAAA;EACA,YAAU;EACV,YAAS;EACT,YAAU;EACV,YAAU;EACV,YAAU;EACV,YAAU;EACV,YAAU;EACV,YAAU;EACV,WAAA;EACA,YAAU;EACV,YAAU;EACV,YAAU;EACV,YAAS;EACT,WAAA;EACA,YAAS;EACT,WAAA;EACA,YAAU;EACV,UAAA;EACA,YAAU;EACV,YAAU;EACV,YAAS;EACT,WAAA;EACA,WAAA;EACA,YAAS;EACT,YAAU;EACV,YAAS;EACT,YAAU;EACV,WAAA;EACA,WAAS;EACT,WAAA;EACA,WAAA;EACA,YAAU;EACV,YAAU;EACV,YAAU;EACV,YAAU;EACV,YAAU;EACV,YAAU;EACV,YAAU;EACV,YAAU;EACV,WAAS;EACT,YAAU;EACV,YAAU;EACV,YAAS;EACT,YAAU;EACV,YAAU;EACV,WAAA;EACA,YAAS;EACT,WAAA;EACA,YAAU;EACV,YAAU;EACV,YAAU;EACV,YAAU;EACV,YAAU;EACV,WAAA;EACA,YAAU;EACV,WAAS;EACT,YAAU;EACV,YAAS;EACT,YAAU;EACV,YAAU;EACV,YAAU;EACV,WAAA;EACA,YAAU;EACV,YAAU;EACV,YAAU;EACV,YAAU;EACV,YAAU;EACV,WAAA;EACA,WAAS;EACT,YAAU;EACV,WAAA;EACA,YAAU;EACV,YAAU;EACV,YAAU;EACV,YAAS;EACT,YAAS;EACT,YAAU;EACV,YAAU;EACV,YAAS;EACT,WAAA;EACA,YAAS;EACT,YAAU;EACV,YAAS;EACT,YAAU;EACV,YAAU;EACV,YAAU;EACV,YAAU;EACV,YAAU;EACV,YAAU;EACV,YAAU;EACV,YAAU;EACV,WAAA;EACA,YAAU;EACV,WAAA;EACA,YAAU;EACV,UAAA;EACA,YAAS;EACT,YAAU;EACV,YAAU;EACV,YAAU;EACV,WAAA;EACA,YAAU;EACV,YAAS;EACT,YAAU;EACV,WAAA;EACA,YAAU;EACV,YAAU;EACV,YAAU;EACV,YAAS;EACT,YAAU;EACV,YAAU;EACV,WAAS;EACT,YAAU;EACV,YAAU;EACV,YAAU;EACV,YAAS;EACT,YAAS;EACT,YAAU;EACV,YAAU;EACV,YAAU;EACV,WAAU;EACV,YAAS;EACT,WAAS;EACT,YAAU;EACV,WAAS;EACT,YAAU;EACV,YAAU;EACV,YAAU;EACV,YAAS;EACT,YAAU;EACV,WAAA;EACA,YAAS;EACT,YAAU;EACV,WAAS;EACT,YAAU;EACV,WAAA;EACA,YAAS;EACT,YAAU;EACV,WAAS;EACT,YAAU;EACV,YAAU;EACV,YAAU;EACV,YAAU;EACV,YAAU;EACV,YAAU;EACV,YAAS;EACT,YAAU;EACV,YAAU;EACV,YAAU;EACV,WAAS;EACT,YAAU;EACV,YAAU;EACV,WAAA;EACA,YAAU;EACV,YAAU;EACV,YAAU;EACV,WAAA;EACA,YAAS;EACT,YAAU;EACV,YAAU;EACV,YAAU;EACV,YAAU;EACV,YAAU;EACV,YAAU;EACV,YAAU;EACV,WAAA;EACA,YAAU;EACV,WAAA;EACA,YAAS;EACT,YAAU;EACV,YAAU;EACV,YAAS;EACT,YAAU;EACV,YAAU;EACV,YAAS;EACT,YAAU;EACV,YAAU;EACV,YAAU;EACV,WAAA;EACA,YAAU;EACV,YAAU;EACV,YAAU;EACV,YAAS;EACT,YAAU;EACV,WAAA;EACA,WAAS;EACT,YAAU;EACV,YAAS;EACT,WAAA;EACA,YAAU;EACV,WAAS;EACT,YAAU;EACV,WAAA;EACA,YAAU;EACV,YAAU;EACV,YAAU;EACV,YAAU;EACV,YAAS;EACT,YAAU;EACV,YAAU;EACV,YAAS;EACT,YAAU;EACV,YAAU;EACV,YAAU;EACV,YAAS;EACT,YAAU;EACV,WAAA;EACA,YAAS;EACT,YAAS;EACT,YAAU;EACV,YAAS;EACT,YAAS;EACT,WAAA;EACA,YAAU;EACV,YAAS;EACT,YAAU;EACV,YAAU;EACV,YAAS;EACT,WAAA;EACA,YAAU;EACV,YAAU;EACV,WAAA;EACA,YAAS;EACT,YAAS;EACT,YAAU;EACV,WAAA;EACA,WAAA;EACA,YAAU;EACV,YAAU;EACV,YAAU;EACV,YAAU;EACV,WAAA;EACA,WAAA;EACA,YAAU;EACV,WAAA;EACA,YAAU;EACV,YAAU;EACV,YAAU;EACV,WAAA;EACA,YAAU;EACV,YAAU;EACV,WAAS;EACT,YAAU;EACV,WAAA;EACA,YAAU;EACV,YAAU;EACV,WAAA;EACA,YAAU;EACV,WAAA;EACA,YAAU;EACV,YAAU;EACV,UAAA;EACA,YAAU;EACV,YAAU;EACV,YAAU;EACV,WAAS;EACT,YAAU;EACV,YAAU;EACV,YAAU;EACV,WAAA;EACA,YAAU;EACV,YAAU;EACV,YAAU;EACV,YAAU;EACV,YAAU;EACV,YAAU;EACV,YAAU;EACV,WAAA;EACA,YAAU;EACV,YAAS;EACT,YAAU;EACV,YAAU;EACV,YAAU;EACV,YAAU;EACV,YAAU;EACV,YAAS;EACT,YAAU;EACV,YAAU;EACV,WAAS;EACT,YAAU;EACV,YAAS;EACT,WAAA;EACA,YAAU;EACV,YAAU;EACV,WAAS;EACT,YAAU;EACV,YAAU;EACV,YAAS;EACT,YAAS;EACT,YAAU;EACV,YAAU;EACV,YAAU;EACV,WAAA;EACA,YAAU;EACV,YAAU;EACV,WAAS;EACT,YAAU;EACV,WAAA;EACA,YAAU;EACV,YAAU;EACV,WAAA;EACA,YAAS;EACT,YAAU;EACV,YAAU;EACV,YAAU;EACV,YAAS;EACT,YAAU;EACV,WAAA;EACA,YAAU;EACV,YAAU;EACV,WAAA;EACA,YAAU;EACV,YAAU;EACV,YAAS;EACT,WAAA;EACA,YAAU;EACV,YAAS;EACT,WAAA;EACA,WAAA;EACA,YAAU;EACV,WAAA;EACA,WAAA;EACA,YAAU;EACV,YAAU;EACV,WAAS;EACT,YAAU;EACV,YAAU;EACV,WAAA;EACA,YAAS;EACT,YAAU;EACV,YAAU;EACV,YAAU;EACV,WAAS;EACT,WAAA;EACA,YAAU;EACV,YAAU;EACV,YAAU;EACV,YAAU;EACV,YAAU;EACV,YAAU;EACV,YAAU;EACV,YAAU;EACV,YAAS;EACT,YAAU;EACV,YAAS;EACT,YAAU;EACV,YAAU;EACV,YAAU;EACV,YAAS;EACT,YAAU;EACV,YAAU;EACV,WAAA;EACA,YAAS;EACT,YAAU;EACV,YAAU;EACV,YAAS;EACT,YAAU;EACV,YAAS;EACT,YAAS;EACT,YAAS;EACT,YAAU;EACV,YAAU;EACV,YAAU;EACV,YAAU;EACV,YAAS;EACT,WAAA;EACA,YAAU;EACV,YAAU;EACV,YAAU;EACV,YAAU;EACV,YAAU;EACV,YAAU;EACV,YAAS;EACT,YAAU;EACV,YAAU;EACV,YAAU;EACV,YAAU;EACV,YAAU;EACV,YAAU;EACV,WAAS;EACT,YAAU;EACV,YAAU;EACV,YAAU;EACV,YAAU;EACV,YAAU;EACV,WAAA;EACA,YAAS;EACT,YAAU;EACV,WAAA;EACA,YAAU;EACV,WAAA;EACA,YAAU;EACV,YAAU;EACV,YAAU;EACV,WAAA;EACA,YAAU;EACV,YAAU;EACV,WAAA;EACA,WAAA;EACA,YAAU;EACV,YAAU;EACV,YAAU;EACV,YAAU;EACV,YAAU;EACV,YAAU;EACV,WAAS;EACT,YAAS;EACT,YAAS;EACT,YAAU;EACV,YAAU;EACV,YAAU;EACV,WAAA;EACA,YAAS;EACT,YAAU;EACV,YAAU;EACV,WAAA;EACA,YAAU;EACV,YAAU;EACV,YAAU;EACV,YAAU;EACV,YAAU;EACV,YAAU;EACV,YAAS;EACT,WAAS;EACT,YAAU;EACV,YAAU;EACV,WAAA;EACA,YAAU;EACV,YAAU;EACV,YAAU;EACV,YAAU;EACV,YAAS;EACT,YAAS;EACT,YAAS;EACT,WAAA;EACA,YAAU;EACV,YAAU;EACV,YAAU;EACV,WAAA;EACA,YAAU;EACV,YAAU;EACV,YAAU;EACV,WAAA;EACH,YAAA;;EC3yBK,YAAO;cAEH;EACF,YAAA;cACH;EAED,YAAM;cACI;EACN,YAAM;EACN,WAAA;cACM;EACN,WAAA;EACA,YAAA;cACH;EAED,YAAM;EACF,WAAA;EACA,YAAM;cACD;EACD,YAAA;EACH,WAAA;cACD;cACH;aAEc;EACX,YAAM;aACN;EACA,WAAI;EACA,SAAA;E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",
  "names": ["store", "node", "result", "i", "WorkerActions", "WorkerAPIs", "DBOperation"]
}
